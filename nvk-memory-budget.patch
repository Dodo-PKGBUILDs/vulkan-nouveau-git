From 01cdbc8fd84c722993903eebfbaf1c4cd3ac94bf Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Thu, 8 Dec 2022 00:00:52 +0100
Subject: [PATCH] nvk: implement EXT_memory_budget

A simple implementation of the memory budget. Logs the memory allocated
and freed with vkAllocateMemory and vkFreeMemory.

Inspiration is taken from the other drivers. Like those this also sets
the budget to 90% of the available memory.

Passes dEQP-VK.info.device_memory_budget
---
 src/nouveau/vulkan/nvk_device_memory.c   | 17 +++++++++++++++++
 src/nouveau/vulkan/nvk_physical_device.c | 21 +++++++++++++++++++++
 src/nouveau/vulkan/nvk_physical_device.h |  1 +
 3 files changed, 39 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_device_memory.c b/src/nouveau/vulkan/nvk_device_memory.c
index 055a868393b..5e948b4c239 100644
--- a/src/nouveau/vulkan/nvk_device_memory.c
+++ b/src/nouveau/vulkan/nvk_device_memory.c
@@ -12,6 +12,7 @@
 #include "nvk_physical_device.h"
 
 #include "nv_push.h"
+#include "util/u_atomic.h"
 
 #include <inttypes.h>
 #include <sys/mman.h>
@@ -153,6 +154,15 @@ nvk_GetMemoryFdPropertiesKHR(VkDevice device,
    return VK_SUCCESS;
 }
 
+static uint32_t
+nvk_bo_heap_index(struct nvk_device *dev, struct nvk_device_memory *mem)
+{
+   if (dev->pdev->mem_type_count > 1 && mem->bo->flags & NOUVEAU_WS_BO_GART)
+      return 1;
+
+   return 0;
+}
+
 VKAPI_ATTR VkResult VKAPI_CALL
 nvk_AllocateMemory(VkDevice device,
                    const VkMemoryAllocateInfo *pAllocateInfo,
@@ -244,6 +254,9 @@ nvk_AllocateMemory(VkDevice device,
       close(fd_info->fd);
    }
 
+   uint32_t heap_index = nvk_bo_heap_index(dev, mem);
+   p_atomic_add(&dev->pdev->mem_usage[heap_index], mem->bo->size);
+
    *pMem = nvk_device_memory_to_handle(mem);
 
    return VK_SUCCESS;
@@ -269,6 +282,10 @@ nvk_FreeMemory(VkDevice device,
    if (mem->map)
       nouveau_ws_bo_unmap(mem->bo, mem->map);
 
+   uint32_t heap_index = nvk_bo_heap_index(dev, mem);
+   p_atomic_add(&dev->pdev->mem_usage[heap_index],
+                -((int64_t)mem->bo->size));
+
    nouveau_ws_bo_destroy(mem->bo);
 
    vk_device_memory_destroy(&dev->vk, pAllocator, &mem->vk);
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 6e9411c3f62..9fde4a7ee6e 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -123,6 +123,7 @@ nvk_get_device_extensions(const struct nv_device_info *info,
       .EXT_inline_uniform_block = true,
       .EXT_line_rasterization = true,
       .EXT_load_store_op_none = true,
+      .EXT_memory_budget = true,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
       .EXT_pci_bus_info = info->type == NV_DEVICE_TYPE_DIS,
@@ -942,6 +943,26 @@ nvk_GetPhysicalDeviceMemoryProperties2(
    vk_foreach_struct(ext, pMemoryProperties->pNext)
    {
       switch (ext->sType) {
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {
+         VkPhysicalDeviceMemoryBudgetPropertiesEXT *p = (void *)ext;
+
+         for (unsigned i = 0; i < pdev->mem_heap_count; i++) {
+            p->heapUsage[i] = pdev->mem_usage[i];
+
+            /* Set heapBudget to 90% of the available memory */
+            uint64_t heap_available = pdev->mem_heaps[i].size - pdev->mem_usage[i];
+            p->heapBudget[i] = heap_available * 9 / 10;
+         }
+
+         /* The heapBudget and heapUsage values must be zero for array elements
+          * greater than or equal to VkPhysicalDeviceMemoryProperties::memoryHeapCount
+          */
+         for (unsigned i = pdev->mem_heap_count; i < VK_MAX_MEMORY_HEAPS; i++) {
+            p->heapBudget[i] = 0u;
+            p->heapUsage[i] = 0u;
+         }
+         break;
+      }
       default:
          nvk_debug_ignored_stype(ext->sType);
          break;
diff --git a/src/nouveau/vulkan/nvk_physical_device.h b/src/nouveau/vulkan/nvk_physical_device.h
index 738ffcfbe08..f8b43d88041 100644
--- a/src/nouveau/vulkan/nvk_physical_device.h
+++ b/src/nouveau/vulkan/nvk_physical_device.h
@@ -31,6 +31,7 @@ struct nvk_physical_device {
    // TODO: add mapable VRAM heap if possible
    VkMemoryHeap mem_heaps[2];
    VkMemoryType mem_types[2];
+   VkDeviceSize mem_usage[2];
    uint8_t mem_heap_count;
    uint8_t mem_type_count;
 
-- 
2.42.0

