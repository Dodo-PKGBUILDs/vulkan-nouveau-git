From ab4ee8a9590a7eea7c36a2cc4c1be205c90abf1f Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Thu, 8 Dec 2022 00:00:52 +0100
Subject: [PATCH] nvk: implement EXT_memory_budget

A simple implementation of the memory budget. Logs the memory allocated
and freed with vkAllocateMemory and vkFreeMemory.

Inspiration is taken from the other drivers. Like those this also sets
the budget to 90% of the available memory.

Passes dEQP-VK.info.device_memory_budget
---
 src/nouveau/vulkan/nvk_device_memory.c   | 17 +++++++++++++++++
 src/nouveau/vulkan/nvk_physical_device.c | 21 +++++++++++++++++++++
 src/nouveau/vulkan/nvk_physical_device.h |  1 +
 3 files changed, 39 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_device_memory.c b/src/nouveau/vulkan/nvk_device_memory.c
index a645b073c67..7830d6329fd 100644
--- a/src/nouveau/vulkan/nvk_device_memory.c
+++ b/src/nouveau/vulkan/nvk_device_memory.c
@@ -12,6 +12,7 @@
 #include "nvk_physical_device.h"
 
 #include "nv_push.h"
+#include "util/u_atomic.h"
 
 #include <inttypes.h>
 #include <sys/mman.h>
@@ -143,6 +144,15 @@ nvk_GetMemoryFdPropertiesKHR(VkDevice device,
    return VK_SUCCESS;
 }
 
+static uint32_t
+nvk_bo_heap_index(struct nvk_device *dev, struct nvk_device_memory *mem)
+{
+   if (dev->pdev->mem_type_count > 1 && mem->bo->flags & NOUVEAU_WS_BO_GART)
+      return 1;
+
+   return 0;
+}
+
 VKAPI_ATTR VkResult VKAPI_CALL
 nvk_AllocateMemory(VkDevice device,
                    const VkMemoryAllocateInfo *pAllocateInfo,
@@ -234,6 +244,9 @@ nvk_AllocateMemory(VkDevice device,
       close(fd_info->fd);
    }
 
+   uint32_t heap_index = nvk_bo_heap_index(dev, mem);
+   p_atomic_add(&dev->pdev->mem_usage[heap_index], mem->bo->size);
+
    *pMem = nvk_device_memory_to_handle(mem);
 
    return VK_SUCCESS;
@@ -259,6 +272,10 @@ nvk_FreeMemory(VkDevice device,
    if (mem->map)
       nouveau_ws_bo_unmap(mem->bo, mem->map);
 
+   uint32_t heap_index = nvk_bo_heap_index(dev, mem);
+   p_atomic_add(&dev->pdev->mem_usage[heap_index],
+                -((int64_t)mem->bo->size));
+
    nouveau_ws_bo_destroy(mem->bo);
 
    vk_device_memory_destroy(&dev->vk, pAllocator, &mem->vk);
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 086a72fd33b..de91d699d00 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -177,6 +177,7 @@ nvk_get_device_extensions(const struct nvk_instance *instance,
       .EXT_line_rasterization = true,
       .EXT_load_store_op_none = true,
       .EXT_map_memory_placed = true,
+      .EXT_memory_budget = true,
       .EXT_multi_draw = true,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
@@ -1165,6 +1166,26 @@ nvk_GetPhysicalDeviceMemoryProperties2(
    vk_foreach_struct(ext, pMemoryProperties->pNext)
    {
       switch (ext->sType) {
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {
+         VkPhysicalDeviceMemoryBudgetPropertiesEXT *p = (void *)ext;
+
+         for (unsigned i = 0; i < pdev->mem_heap_count; i++) {
+            p->heapUsage[i] = pdev->mem_usage[i];
+
+            /* Set heapBudget to 90% of the available memory */
+            uint64_t heap_available = pdev->mem_heaps[i].size - pdev->mem_usage[i];
+            p->heapBudget[i] = heap_available * 9 / 10;
+         }
+
+         /* The heapBudget and heapUsage values must be zero for array elements
+          * greater than or equal to VkPhysicalDeviceMemoryProperties::memoryHeapCount
+          */
+         for (unsigned i = pdev->mem_heap_count; i < VK_MAX_MEMORY_HEAPS; i++) {
+            p->heapBudget[i] = 0u;
+            p->heapUsage[i] = 0u;
+         }
+         break;
+      }
       default:
          nvk_debug_ignored_stype(ext->sType);
          break;
diff --git a/src/nouveau/vulkan/nvk_physical_device.h b/src/nouveau/vulkan/nvk_physical_device.h
index d5c4bac91d9..67e3d524aca 100644
--- a/src/nouveau/vulkan/nvk_physical_device.h
+++ b/src/nouveau/vulkan/nvk_physical_device.h
@@ -39,6 +39,7 @@ struct nvk_physical_device {
    // TODO: add mapable VRAM heap if possible
    VkMemoryHeap mem_heaps[2];
    VkMemoryType mem_types[2];
+   VkDeviceSize mem_usage[2];
    uint8_t mem_heap_count;
    uint8_t mem_type_count;
 
-- 
2.43.1

