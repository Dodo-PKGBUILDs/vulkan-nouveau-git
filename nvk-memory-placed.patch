From 6e17e72f36256aedb1aabbb6758cbae8548afd22 Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Tue, 13 Feb 2024 11:50:53 -0600
Subject: [PATCH 1/4] WIP: Update Vulkan XML and headers for
 VK_EXT_map_memory_placed

---
 include/vulkan/vulkan_core.h | 39 ++++++++++++++++++++++++++++++++
 src/vulkan/registry/vk.xml   | 44 +++++++++++++++++++++++++++++++-----
 2 files changed, 77 insertions(+), 6 deletions(-)

diff --git a/include/vulkan/vulkan_core.h b/include/vulkan/vulkan_core.h
index a4666edc554fe..5c8b822393409 100644
--- a/include/vulkan/vulkan_core.h
+++ b/include/vulkan/vulkan_core.h
@@ -767,6 +767,9 @@ typedef enum VkStructureType {
     VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = 1000270009,
     VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = 1000271000,
     VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = 1000271001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
+    VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
     VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT = 1000274000,
     VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT = 1000274001,
@@ -2424,6 +2427,11 @@ typedef enum VkPipelineStageFlagBits {
     VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
 } VkPipelineStageFlagBits;
 typedef VkFlags VkPipelineStageFlags;
+
+typedef enum VkMemoryMapFlagBits {
+    VK_MEMORY_MAP_PLACED_BIT_EXT = 0x00000001,
+    VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
+} VkMemoryMapFlagBits;
 typedef VkFlags VkMemoryMapFlags;
 
 typedef enum VkSparseMemoryBindFlagBits {
@@ -10495,6 +10503,11 @@ VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineExecutableInternalRepresentationsKHR
 #define VK_KHR_map_memory2 1
 #define VK_KHR_MAP_MEMORY_2_SPEC_VERSION  1
 #define VK_KHR_MAP_MEMORY_2_EXTENSION_NAME "VK_KHR_map_memory2"
+
+typedef enum VkMemoryUnmapFlagBitsKHR {
+    VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
+    VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
+} VkMemoryUnmapFlagBitsKHR;
 typedef VkFlags VkMemoryUnmapFlagsKHR;
 typedef struct VkMemoryMapInfoKHR {
     VkStructureType     sType;
@@ -15182,6 +15195,32 @@ VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout2EXT(
 #endif
 
 
+// VK_EXT_map_memory_placed is a preprocessor guard. Do not pass it to API calls.
+#define VK_EXT_map_memory_placed 1
+#define VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION 1
+#define VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME "VK_EXT_map_memory_placed"
+typedef struct VkPhysicalDeviceMapMemoryPlacedFeaturesEXT {
+    VkStructureType    sType;
+    void*              pNext;
+    VkBool32           memoryMapPlaced;
+    VkBool32           memoryMapRangePlaced;
+    VkBool32           memoryUnmapReserve;
+} VkPhysicalDeviceMapMemoryPlacedFeaturesEXT;
+
+typedef struct VkPhysicalDeviceMapMemoryPlacedPropertiesEXT {
+    VkStructureType    sType;
+    void*              pNext;
+    VkDeviceSize       minPlacedMemoryMapAlignment;
+} VkPhysicalDeviceMapMemoryPlacedPropertiesEXT;
+
+typedef struct VkMemoryMapPlacedInfoEXT {
+    VkStructureType    sType;
+    const void*        pNext;
+    void*              pPlacedAddress;
+} VkMemoryMapPlacedInfoEXT;
+
+
+
 // VK_EXT_shader_atomic_float2 is a preprocessor guard. Do not pass it to API calls.
 #define VK_EXT_shader_atomic_float2 1
 #define VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION 1
diff --git a/src/vulkan/registry/vk.xml b/src/vulkan/registry/vk.xml
index fb92b7c2373bc..64703f74df2fc 100644
--- a/src/vulkan/registry/vk.xml
+++ b/src/vulkan/registry/vk.xml
@@ -338,8 +338,8 @@ typedef void* <name>MTLSharedEvent_id</name>;
         <type requires="VkCommandBufferResetFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferResetFlags</name>;</type>
         <type requires="VkCommandBufferUsageFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferUsageFlags</name>;</type>
         <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>
-        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>
-        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryUnmapFlagsKHR</name>;</type>
+        <type requires="VkMemoryMapFlagBits"              category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>
+        <type requires="VkMemoryUnmapFlagBitsKHR"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryUnmapFlagsKHR</name>;</type>
         <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>
         <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>
         <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>
@@ -619,6 +619,7 @@ typedef void* <name>MTLSharedEvent_id</name>;
         <type name="VkFormat" category="enum"/>
         <type name="VkFormatFeatureFlagBits" category="enum"/>
         <type name="VkFrontFace" category="enum"/>
+        <type name="VkMemoryMapFlagBits" category="enum"/>
         <type name="VkImageAspectFlagBits" category="enum"/>
         <type name="VkImageCreateFlagBits" category="enum"/>
         <type name="VkImageLayout" category="enum"/>
@@ -872,6 +873,7 @@ typedef void* <name>MTLSharedEvent_id</name>;
         <type name="VkLatencyMarkerNV" category="enum"/>
         <type name="VkOutOfBandQueueTypeNV" category="enum"/>
         <type name="VkPhysicalDeviceSchedulingControlsFlagBitsARM" category="enum"/>
+        <type name="VkMemoryUnmapFlagBitsKHR" category="enum"/>
 
             <comment>Enumerated types in the header, but not used by the API</comment>
         <type name="VkVendorId" category="enum"/>
@@ -9078,6 +9080,23 @@ typedef void* <name>MTLSharedEvent_id</name>;
             <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
             <member><type>VkBool32</type>                           <name>shaderQuadControl</name></member>
         </type>
+        <type category="struct" name="VkPhysicalDeviceMapMemoryPlacedFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>memoryMapPlaced</name></member>
+            <member><type>VkBool32</type>                         <name>memoryMapRangePlaced</name></member>
+            <member><type>VkBool32</type>                         <name>memoryUnmapReserve</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMapMemoryPlacedPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member limittype="min,pot"><type>VkDeviceSize</type> <name>minPlacedMemoryMapAlignment</name></member>
+        </type>
+        <type category="struct" name="VkMemoryMapPlacedInfoEXT" structextends="VkMemoryMapInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member noautovalidity="true"><type>void</type>*  <name>pPlacedAddress</name></member>
+        </type>
     </types>
 
 
@@ -9837,6 +9856,8 @@ typedef void* <name>MTLSharedEvent_id</name>;
         <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT" comment="Optional"/>
         <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"                 comment="Optional"/>
     </enums>
+    <enums name="VkMemoryMapFlagBits" type="bitmask">
+    </enums>
     <enums name="VkImageAspectFlagBits" type="bitmask">
         <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
         <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
@@ -11211,6 +11232,8 @@ typedef void* <name>MTLSharedEvent_id</name>;
         <enum value="0"    name="VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV"/>
         <enum value="1"    name="VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV"/>
     </enums>
+    <enums name="VkMemoryUnmapFlagBitsKHR" type="bitmask">
+    </enums>
 
     <commands comment="Vulkan command definitions">
         <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER">
@@ -15175,7 +15198,7 @@ typedef void* <name>MTLSharedEvent_id</name>;
             <param>const <type>VkMemoryMapInfoKHR</type>* <name>pMemoryMapInfo</name></param>
             <param optional="false,true"><type>void</type>** <name>ppData</name></param>
         </command>
-        <command successcodes="VK_SUCCESS">
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_MEMORY_MAP_FAILED">
             <proto><type>VkResult</type> <name>vkUnmapMemory2KHR</name></proto>
             <param><type>VkDevice</type> <name>device</name></param>
             <param>const <type>VkMemoryUnmapInfoKHR</type>* <name>pMemoryUnmapInfo</name></param>
@@ -15491,6 +15514,7 @@ typedef void* <name>MTLSharedEvent_id</name>;
         <require comment="Memory commands">
             <type name="VkMappedMemoryRange"/>
             <type name="VkMemoryAllocateInfo"/>
+            <type name="VkMemoryMapFlagBits"/>
             <type name="VkMemoryMapFlags"/>
             <command name="vkAllocateMemory"/>
             <command name="vkFreeMemory"/>
@@ -20643,10 +20667,18 @@ typedef void* <name>MTLSharedEvent_id</name>;
                 <command name="vkUnmapMemory2KHR"/>
             </require>
         </extension>
-        <extension name="VK_INTEL_extension_273" number="273" type="device" author="INTEL" contact="Faith Ekstrand @gfxstrand" supported="disabled">
+        <extension name="VK_EXT_map_memory_placed" number="273" type="device" depends="VK_KHR_map_memory2" author="EXT" contact="Faith Ekstrand @gfxstrand" supported="vulkan">
             <require>
-                <enum value="0"                                             name="VK_INTEL_EXTENSION_273_SPEC_VERSION"/>
-                <enum value="&quot;VK_INTEL_extension_273&quot;"            name="VK_INTEL_EXTENSION_273_EXTENSION_NAME"/>
+                <enum value="1"                                         name="VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_map_memory_placed&quot;"      name="VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT"/>
+                <enum bitpos="0" extends="VkMemoryMapFlagBits"          name="VK_MEMORY_MAP_PLACED_BIT_EXT"/>
+                <enum bitpos="0" extends="VkMemoryUnmapFlagBitsKHR"     name="VK_MEMORY_UNMAP_RESERVE_BIT_EXT"/>
+                <type name="VkPhysicalDeviceMapMemoryPlacedFeaturesEXT"/>
+                <type name="VkPhysicalDeviceMapMemoryPlacedPropertiesEXT"/>
+                <type name="VkMemoryMapPlacedInfoEXT"/>
             </require>
         </extension>
         <extension name="VK_EXT_shader_atomic_float2" number="274" type="device" depends="VK_EXT_shader_atomic_float" author="EXT" contact="Faith Ekstrand @gfxstrand" supported="vulkan">
-- 
GitLab


From 0cc13c0f9d04e997ef1c9991eaf968234f62f916 Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Tue, 13 Feb 2024 11:45:50 -0600
Subject: [PATCH 2/4] nvk: Use nouveau_ws_bo_new_mapped() for descriptors

---
 src/nouveau/vulkan/nvk_descriptor_set.c   | 11 ++++-------
 src/nouveau/vulkan/nvk_descriptor_table.c | 16 +++++-----------
 2 files changed, 9 insertions(+), 18 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_descriptor_set.c b/src/nouveau/vulkan/nvk_descriptor_set.c
index cb78ab3a91b39..2d1b97d0a477a 100644
--- a/src/nouveau/vulkan/nvk_descriptor_set.c
+++ b/src/nouveau/vulkan/nvk_descriptor_set.c
@@ -436,17 +436,14 @@ nvk_CreateDescriptorPool(VkDevice _device,
       return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    if (bo_size) {
-      uint32_t flags = NOUVEAU_WS_BO_GART | NOUVEAU_WS_BO_MAP | NOUVEAU_WS_BO_NO_SHARE;
-      pool->bo = nouveau_ws_bo_new(dev->ws_dev, bo_size, 0, flags);
+      uint32_t flags = NOUVEAU_WS_BO_GART | NOUVEAU_WS_BO_NO_SHARE;
+      pool->bo = nouveau_ws_bo_new_mapped(dev->ws_dev, bo_size, 0, flags,
+                                          NOUVEAU_WS_BO_WR,
+                                          (void **)&pool->mapped_ptr);
       if (!pool->bo) {
          nvk_destroy_descriptor_pool(dev, pAllocator, pool);
          return vk_error(dev, VK_ERROR_OUT_OF_DEVICE_MEMORY);
       }
-      pool->mapped_ptr = nouveau_ws_bo_map(pool->bo, NOUVEAU_WS_BO_WR);
-      if (!pool->mapped_ptr) {
-         nvk_destroy_descriptor_pool(dev, pAllocator, pool);
-         return vk_error(dev, VK_ERROR_OUT_OF_DEVICE_MEMORY);
-      }
    }
 
    pool->size = bo_size;
diff --git a/src/nouveau/vulkan/nvk_descriptor_table.c b/src/nouveau/vulkan/nvk_descriptor_table.c
index 853f5b40ccfc0..adc35f1265aed 100644
--- a/src/nouveau/vulkan/nvk_descriptor_table.c
+++ b/src/nouveau/vulkan/nvk_descriptor_table.c
@@ -21,22 +21,16 @@ nvk_descriptor_table_grow_locked(struct nvk_device *dev,
    assert(new_alloc > table->alloc && new_alloc <= table->max_alloc);
 
    const uint32_t new_bo_size = new_alloc * table->desc_size;
-   new_bo = nouveau_ws_bo_new(dev->ws_dev, new_bo_size, 256,
-                              NOUVEAU_WS_BO_LOCAL |
-                              NOUVEAU_WS_BO_MAP |
-                              NOUVEAU_WS_BO_NO_SHARE);
+   new_bo = nouveau_ws_bo_new_mapped(dev->ws_dev, new_bo_size, 256,
+                                     NOUVEAU_WS_BO_LOCAL |
+                                     NOUVEAU_WS_BO_NO_SHARE,
+                                     NOUVEAU_WS_BO_WR,
+                                     &new_map);
    if (new_bo == NULL) {
       return vk_errorf(dev, VK_ERROR_OUT_OF_DEVICE_MEMORY,
                        "Failed to allocate the image descriptor table");
    }
 
-   new_map = nouveau_ws_bo_map(new_bo, NOUVEAU_WS_BO_WR);
-   if (new_map == NULL) {
-      nouveau_ws_bo_destroy(new_bo);
-      return vk_errorf(dev, VK_ERROR_OUT_OF_DEVICE_MEMORY,
-                       "Failed to map the image descriptor table");
-   }
-
    if (table->bo) {
       assert(new_bo_size >= table->bo->size);
       memcpy(new_map, table->map, table->bo->size);
-- 
GitLab


From 35298603b3f3c691255f21ad57929cb378277b02 Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Tue, 13 Feb 2024 11:49:06 -0600
Subject: [PATCH 3/4] nouveau/winsys: Add a fixed_addr to nouveau_ws_bo_map

---
 src/nouveau/vulkan/nvk_device_memory.c |  4 ++--
 src/nouveau/vulkan/nvk_heap.c          |  2 +-
 src/nouveau/winsys/nouveau_bo.c        | 15 +++++++++++----
 src/nouveau/winsys/nouveau_bo.h        |  4 +++-
 4 files changed, 17 insertions(+), 8 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_device_memory.c b/src/nouveau/vulkan/nvk_device_memory.c
index 07ac6e6aa7978..9c6a0b9132c0f 100644
--- a/src/nouveau/vulkan/nvk_device_memory.c
+++ b/src/nouveau/vulkan/nvk_device_memory.c
@@ -206,7 +206,7 @@ nvk_AllocateMemory(VkDevice device,
 
    if (dev->ws_dev->debug_flags & NVK_DEBUG_ZERO_MEMORY) {
       if (type->propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
-         void *map = nouveau_ws_bo_map(mem->bo, NOUVEAU_WS_BO_RDWR);
+         void *map = nouveau_ws_bo_map(mem->bo, NOUVEAU_WS_BO_RDWR, NULL);
          if (map == NULL) {
             result = vk_errorf(dev, VK_ERROR_OUT_OF_HOST_MEMORY,
                                "Memory map failed");
@@ -307,7 +307,7 @@ nvk_MapMemory2KHR(VkDevice device,
                        "Memory object already mapped.");
    }
 
-   mem->map = nouveau_ws_bo_map(mem->bo, NOUVEAU_WS_BO_RDWR);
+   mem->map = nouveau_ws_bo_map(mem->bo, NOUVEAU_WS_BO_RDWR, NULL);
    if (mem->map == NULL) {
       return vk_errorf(dev, VK_ERROR_MEMORY_MAP_FAILED,
                        "Memory object couldn't be mapped.");
diff --git a/src/nouveau/vulkan/nvk_heap.c b/src/nouveau/vulkan/nvk_heap.c
index 182bebe0560c9..d6b6d55539af2 100644
--- a/src/nouveau/vulkan/nvk_heap.c
+++ b/src/nouveau/vulkan/nvk_heap.c
@@ -111,7 +111,7 @@ nvk_heap_grow_locked(struct nvk_device *dev, struct nvk_heap *heap)
 
    void *map = NULL;
    if (heap->map_flags) {
-      map = nouveau_ws_bo_map(bo, heap->map_flags);
+      map = nouveau_ws_bo_map(bo, heap->map_flags, NULL);
       if (map == NULL) {
          nouveau_ws_bo_destroy(bo);
          return vk_errorf(dev, VK_ERROR_OUT_OF_HOST_MEMORY,
diff --git a/src/nouveau/winsys/nouveau_bo.c b/src/nouveau/winsys/nouveau_bo.c
index 17f152870a83b..e8240f9a27131 100644
--- a/src/nouveau/winsys/nouveau_bo.c
+++ b/src/nouveau/winsys/nouveau_bo.c
@@ -163,7 +163,7 @@ nouveau_ws_bo_new_mapped(struct nouveau_ws_device *dev,
    if (!bo)
       return NULL;
 
-   void *map = nouveau_ws_bo_map(bo, map_flags);
+   void *map = nouveau_ws_bo_map(bo, map_flags, NULL);
    if (map == NULL) {
       nouveau_ws_bo_destroy(bo);
       return NULL;
@@ -359,16 +359,23 @@ nouveau_ws_bo_destroy(struct nouveau_ws_bo *bo)
 }
 
 void *
-nouveau_ws_bo_map(struct nouveau_ws_bo *bo, enum nouveau_ws_bo_map_flags flags)
+nouveau_ws_bo_map(struct nouveau_ws_bo *bo,
+                  enum nouveau_ws_bo_map_flags flags,
+                  void *fixed_addr)
 {
-   size_t prot = 0;
+   int prot = 0, map_flags = 0;
 
    if (flags & NOUVEAU_WS_BO_RD)
       prot |= PROT_READ;
    if (flags & NOUVEAU_WS_BO_WR)
       prot |= PROT_WRITE;
 
-   void *res = mmap(NULL, bo->size, prot, MAP_SHARED, bo->dev->fd, bo->map_handle);
+   map_flags = MAP_SHARED;
+   if (fixed_addr != NULL)
+      map_flags |= MAP_FIXED;
+
+   void *res = mmap(fixed_addr, bo->size, prot, map_flags,
+                    bo->dev->fd, bo->map_handle);
    if (res == MAP_FAILED)
       return NULL;
 
diff --git a/src/nouveau/winsys/nouveau_bo.h b/src/nouveau/winsys/nouveau_bo.h
index d931bea44f9d4..8947aec4f071a 100644
--- a/src/nouveau/winsys/nouveau_bo.h
+++ b/src/nouveau/winsys/nouveau_bo.h
@@ -71,7 +71,9 @@ struct nouveau_ws_bo *nouveau_ws_bo_new_mapped(struct nouveau_ws_device *,
 struct nouveau_ws_bo *nouveau_ws_bo_from_dma_buf(struct nouveau_ws_device *,
                                                  int fd);
 void nouveau_ws_bo_destroy(struct nouveau_ws_bo *);
-void *nouveau_ws_bo_map(struct nouveau_ws_bo *, enum nouveau_ws_bo_map_flags);
+void *nouveau_ws_bo_map(struct nouveau_ws_bo *,
+                        enum nouveau_ws_bo_map_flags,
+                        void *fixed_addr);
 bool nouveau_ws_bo_wait(struct nouveau_ws_bo *, enum nouveau_ws_bo_map_flags flags);
 int nouveau_ws_bo_dma_buf(struct nouveau_ws_bo *, int *fd);
 
-- 
GitLab


From 944acfd14536d74dfe72ebacd63d376561c5c776 Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Tue, 13 Feb 2024 12:03:16 -0600
Subject: [PATCH 4/4] nvk: Implement VK_EXT_map_memory_placed

---
 src/nouveau/vulkan/nvk_device_memory.c   | 21 +++++++++++++++++++--
 src/nouveau/vulkan/nvk_physical_device.c | 12 ++++++++++++
 src/nouveau/winsys/nouveau_bo.h          |  8 ++++++++
 3 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_device_memory.c b/src/nouveau/vulkan/nvk_device_memory.c
index 9c6a0b9132c0f..a645b073c674d 100644
--- a/src/nouveau/vulkan/nvk_device_memory.c
+++ b/src/nouveau/vulkan/nvk_device_memory.c
@@ -282,6 +282,13 @@ nvk_MapMemory2KHR(VkDevice device,
       vk_device_memory_range(&mem->vk, pMemoryMapInfo->offset,
                                        pMemoryMapInfo->size);
 
+   void *fixed_addr = NULL;
+   if (pMemoryMapInfo->flags & VK_MEMORY_MAP_PLACED_BIT_EXT) {
+      const VkMemoryMapPlacedInfoEXT *placed_info =
+         vk_find_struct_const(pMemoryMapInfo->pNext, MEMORY_MAP_PLACED_INFO_EXT);
+      fixed_addr = placed_info->pPlacedAddress;
+   }
+
    /* From the Vulkan spec version 1.0.32 docs for MapMemory:
     *
     *  * If size is not equal to VK_WHOLE_SIZE, size must be greater than 0
@@ -307,7 +314,7 @@ nvk_MapMemory2KHR(VkDevice device,
                        "Memory object already mapped.");
    }
 
-   mem->map = nouveau_ws_bo_map(mem->bo, NOUVEAU_WS_BO_RDWR, NULL);
+   mem->map = nouveau_ws_bo_map(mem->bo, NOUVEAU_WS_BO_RDWR, fixed_addr);
    if (mem->map == NULL) {
       return vk_errorf(dev, VK_ERROR_MEMORY_MAP_FAILED,
                        "Memory object couldn't be mapped.");
@@ -322,12 +329,22 @@ VKAPI_ATTR VkResult VKAPI_CALL
 nvk_UnmapMemory2KHR(VkDevice device,
                     const VkMemoryUnmapInfoKHR *pMemoryUnmapInfo)
 {
+   VK_FROM_HANDLE(nvk_device, dev, device);
    VK_FROM_HANDLE(nvk_device_memory, mem, pMemoryUnmapInfo->memory);
 
    if (mem == NULL)
       return VK_SUCCESS;
 
-   nouveau_ws_bo_unmap(mem->bo, mem->map);
+   if (pMemoryUnmapInfo->flags & VK_MEMORY_UNMAP_RESERVE_BIT_EXT) {
+      int err = nouveau_ws_bo_overmap(mem->bo, mem->map);
+      if (err) {
+         return vk_errorf(dev, VK_ERROR_MEMORY_MAP_FAILED,
+                          "Failed to map over original mapping");
+      }
+   } else {
+      nouveau_ws_bo_unmap(mem->bo, mem->map);
+   }
+
    mem->map = NULL;
 
    return VK_SUCCESS;
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index acdacf67e16b8..086a72fd33b00 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -176,6 +176,7 @@ nvk_get_device_extensions(const struct nvk_instance *instance,
       .EXT_inline_uniform_block = true,
       .EXT_line_rasterization = true,
       .EXT_load_store_op_none = true,
+      .EXT_map_memory_placed = true,
       .EXT_memory_budget = true,
       .EXT_multi_draw = true,
       .EXT_mutable_descriptor_type = true,
@@ -470,6 +471,11 @@ nvk_get_device_features(const struct nv_device_info *info,
       .stippledBresenhamLines = true,
       .stippledSmoothLines = true,
 
+      /* VK_EXT_map_memory_placed */
+      .memoryMapPlaced = true,
+      .memoryMapRangePlaced = false,
+      .memoryUnmapReserve = true,
+
       /* VK_EXT_multi_draw */
       .multiDraw = true,
 
@@ -550,6 +556,9 @@ nvk_get_device_properties(const struct nvk_instance *instance,
                                                VK_SAMPLE_COUNT_4_BIT |
                                                VK_SAMPLE_COUNT_8_BIT;
 
+   uint64_t os_page_size = 4096;
+   os_get_page_size(&os_page_size);
+
    *properties = (struct vk_properties) {
       .apiVersion = nvk_get_vk_version(info),
       .driverVersion = vk_get_driver_version(),
@@ -785,6 +794,9 @@ nvk_get_device_properties(const struct nvk_instance *instance,
       /* VK_KHR_line_rasterization */
       .lineSubPixelPrecisionBits = 8,
 
+      /* VK_EXT_map_memory_placed */
+      .minPlacedMemoryMapAlignment = os_page_size,
+
       /* VK_EXT_multi_draw */
       .maxMultiDrawCount = UINT32_MAX,
 
diff --git a/src/nouveau/winsys/nouveau_bo.h b/src/nouveau/winsys/nouveau_bo.h
index 8947aec4f071a..27a2c5ebf5770 100644
--- a/src/nouveau/winsys/nouveau_bo.h
+++ b/src/nouveau/winsys/nouveau_bo.h
@@ -89,6 +89,14 @@ nouveau_ws_bo_unmap(struct nouveau_ws_bo *bo, void *ptr)
    munmap(ptr, bo->size);
 }
 
+static inline int
+nouveau_ws_bo_overmap(struct nouveau_ws_bo *bo, void *ptr)
+{
+   void *map = mmap(ptr, bo->size, PROT_NONE,
+                    MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
+   return map == MAP_FAILED ? -1 : 0;
+}
+
 #ifdef __cplusplus
 }
 #endif
-- 
GitLab

