From 9c098f7632f921debc33f77c5a9d438fcfe54204 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 4 Oct 2023 20:37:40 +0200
Subject: [PATCH 1/8] nvk: loop over stages in MESA order

we do this to make the VkPipelineShaderStageCreateInfo available
when we want to calculate the shader hash
---
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 8485818fcd34..657954108659 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -183,12 +183,20 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                             NULL, 0, &all, NULL, 0, NULL);
    assert(result == VK_SUCCESS);
 
+   const VkPipelineShaderStageCreateInfo *infos[MESA_SHADER_STAGES] = {};
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
 
    for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
       const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
       gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+      infos[stage] = sinfo;
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
 
       vk_pipeline_robustness_state_fill(&dev->vk, &robustness[stage],
                                         pCreateInfo->pNext, sinfo->pNext);
@@ -204,16 +212,19 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       merge_tess_info(&nir[MESA_SHADER_TESS_EVAL]->info, &nir[MESA_SHADER_TESS_CTRL]->info);
    }
 
-   for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
-      const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
-      gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
+
       nvk_lower_nir(dev, nir[stage], &robustness[stage],
                     state.rp->view_mask != 0, pipeline_layout,
                     &pipeline->base.shaders[stage]);
    }
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (nir[stage] == NULL)
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
          continue;
 
       struct nak_fs_key fs_key_tmp, *fs_key = NULL;
-- 
GitLab


From 8261e3502b3e81777e0a6a6784bf6617b9fd1876 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 4 Oct 2023 20:38:01 +0200
Subject: [PATCH 2/8] nvk: add hashing for shaders

---
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  3 ++
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  3 ++
 src/nouveau/vulkan/nvk_shader.c            | 33 ++++++++++++++++++++++
 src/nouveau/vulkan/nvk_shader.h            |  7 +++++
 4 files changed, 46 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index a74b3765aa16..1618a6e1c5b0 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -188,6 +188,9 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
 
    nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
 
+   unsigned char sha1[SHA1_DIGEST_LENGTH];
+   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
+
    result = nvk_compile_nir(pdev, nir, pipeline_flags, &robustness, NULL,
                             shader);
    ralloc_free(nir);
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 657954108659..8f2b621cc26d 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -233,6 +233,9 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
          fs_key = &fs_key_tmp;
       }
 
+      unsigned char sha1[SHA1_DIGEST_LENGTH];
+      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
+
       result = nvk_compile_nir(pdev, nir[stage], pipeline_flags,
                                &robustness[stage], fs_key,
                                &pipeline->base.shaders[stage]);
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index f37bf1f44780..e4dd2b914c60 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -514,3 +514,36 @@ nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
    if (shader->nak)
       nak_shader_bin_destroy(shader->nak);
 }
+
+void
+nvk_hash_shader(unsigned char *hash,
+                const VkPipelineShaderStageCreateInfo *sinfo,
+                const struct vk_pipeline_robustness_state *rstate,
+                const struct vk_pipeline_layout *layout,
+                const struct nak_fs_key *fs_key)
+{
+   struct mesa_sha1 ctx;
+
+   _mesa_sha1_init(&ctx);
+
+   unsigned char stage_sha1[SHA1_DIGEST_LENGTH];
+   vk_pipeline_hash_shader_stage(sinfo, rstate, stage_sha1);
+
+   _mesa_sha1_update(&ctx, stage_sha1, sizeof(stage_sha1));
+
+   if (layout) {
+      _mesa_sha1_update(&ctx, &layout->create_flags,
+                        sizeof(layout->create_flags));
+      _mesa_sha1_update(&ctx, &layout->set_count, sizeof(layout->set_count));
+      for (int i = 0; i < layout->set_count; i++) {
+         struct nvk_descriptor_set_layout *set =
+            vk_to_nvk_descriptor_set_layout(layout->set_layouts[i]);
+         _mesa_sha1_update(&ctx, &set->sha1, sizeof(set->sha1));
+      }
+   }
+
+   if(fs_key)
+      _mesa_sha1_update(&ctx, fs_key, sizeof(*fs_key));
+
+   _mesa_sha1_final(&ctx, hash);
+}
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index dea5cdf0bd6a..d8b019bece91 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -130,6 +130,13 @@ nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader);
 
+void
+nvk_hash_shader(unsigned char *hash,
+                 const VkPipelineShaderStageCreateInfo *sinfo,
+                 const struct vk_pipeline_robustness_state *rstate,
+                 const struct vk_pipeline_layout *layout,
+                 const struct nak_fs_key *fs_key);
+
 /* Codegen wrappers.
  *
  * TODO: Delete these once NAK supports everything.
-- 
GitLab


From 2925989d9bcbfa7f3f99b28d53c21ee4ce93bb86 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Tue, 17 Oct 2023 02:08:33 +0200
Subject: [PATCH 3/8] nvk: allocatable nvk_shaders

This will be needed later when the shader life cycle will be managed
by the pipeline cache
---
 src/nouveau/vulkan/nvk_cmd_buffer.c        |  6 ++++--
 src/nouveau/vulkan/nvk_cmd_dispatch.c      |  4 ++--
 src/nouveau/vulkan/nvk_cmd_draw.c          | 12 ++++++------
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  5 +++--
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 13 +++++++------
 src/nouveau/vulkan/nvk_pipeline.c          | 10 ++++++----
 src/nouveau/vulkan/nvk_pipeline.h          |  2 +-
 src/nouveau/vulkan/nvk_shader.c            | 21 ++++++++++++++++++++-
 src/nouveau/vulkan/nvk_shader.h            |  7 +++++--
 9 files changed, 54 insertions(+), 26 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_cmd_buffer.c b/src/nouveau/vulkan/nvk_cmd_buffer.c
index 53327917092b..b8828b7d350e 100644
--- a/src/nouveau/vulkan/nvk_cmd_buffer.c
+++ b/src/nouveau/vulkan/nvk_cmd_buffer.c
@@ -537,8 +537,10 @@ nvk_CmdBindPipeline(VkCommandBuffer commandBuffer,
    struct nvk_device *dev = nvk_cmd_buffer_device(cmd);
 
    for (unsigned s = 0; s < ARRAY_SIZE(pipeline->shaders); s++) {
-      if (pipeline->shaders[s].info.slm_size)
-         nvk_device_ensure_slm(dev, pipeline->shaders[s].info.slm_size);
+      if(!pipeline->shaders[s])
+         continue;
+      if (pipeline->shaders[s]->info.slm_size)
+         nvk_device_ensure_slm(dev, pipeline->shaders[s]->info.slm_size);
    }
 
    switch (pipelineBindPoint) {
diff --git a/src/nouveau/vulkan/nvk_cmd_dispatch.c b/src/nouveau/vulkan/nvk_cmd_dispatch.c
index 5708c815da62..c43bf3773604 100644
--- a/src/nouveau/vulkan/nvk_cmd_dispatch.c
+++ b/src/nouveau/vulkan/nvk_cmd_dispatch.c
@@ -148,7 +148,7 @@ nvk_compute_local_size(struct nvk_cmd_buffer *cmd)
 {
    const struct nvk_compute_pipeline *pipeline = cmd->state.cs.pipeline;
    const struct nvk_shader *shader =
-      &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+      pipeline->base.shaders[MESA_SHADER_COMPUTE];
 
    return shader->info.cs.local_size[0] *
           shader->info.cs.local_size[1] *
@@ -211,7 +211,7 @@ nvk_flush_compute_state(struct nvk_cmd_buffer *cmd,
    }
 
    const struct nvk_shader *shader =
-      &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+      pipeline->base.shaders[MESA_SHADER_COMPUTE];
    for (uint32_t c = 0; c < shader->cbuf_map.cbuf_count; c++) {
       const struct nvk_cbuf *cbuf = &shader->cbuf_map.cbufs[c];
 
diff --git a/src/nouveau/vulkan/nvk_cmd_draw.c b/src/nouveau/vulkan/nvk_cmd_draw.c
index 22b2b760d2fc..5cbf6b978c8c 100644
--- a/src/nouveau/vulkan/nvk_cmd_draw.c
+++ b/src/nouveau/vulkan/nvk_cmd_draw.c
@@ -934,7 +934,7 @@ nvk_cmd_bind_graphics_pipeline(struct nvk_cmd_buffer *cmd,
     * tessellation parameters at flush_ts_state, as the domain origin can be
     * dynamic.
     */
-   if (nvk_shader_is_enabled(&pipeline->base.shaders[MESA_SHADER_TESS_EVAL])) {
+   if (nvk_shader_is_enabled(pipeline->base.shaders[MESA_SHADER_TESS_EVAL])) {
       BITSET_SET(cmd->vk.dynamic_graphics_state.dirty,
                  MESA_VK_DYNAMIC_TS_DOMAIN_ORIGIN);
    }
@@ -1017,7 +1017,7 @@ nvk_flush_ts_state(struct nvk_cmd_buffer *cmd)
    if (BITSET_TEST(dyn->dirty, MESA_VK_DYNAMIC_TS_DOMAIN_ORIGIN)) {
       const struct nvk_graphics_pipeline *pipeline= cmd->state.gfx.pipeline;
       const struct nvk_shader *shader =
-         &pipeline->base.shaders[MESA_SHADER_TESS_EVAL];
+         pipeline->base.shaders[MESA_SHADER_TESS_EVAL];
 
       if (nvk_shader_is_enabled(shader)) {
          enum nak_ts_prims prims = shader->info.ts.prims;
@@ -1883,8 +1883,8 @@ nvk_flush_descriptors(struct nvk_cmd_buffer *cmd)
 
    uint32_t root_cbuf_count = 0;
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      const struct nvk_shader *shader = &pipeline->base.shaders[stage];
-      if (shader->code_size == 0)
+      const struct nvk_shader *shader = pipeline->base.shaders[stage];
+      if (!shader || shader->code_size == 0)
          continue;
 
       uint32_t group = stage;
@@ -1953,8 +1953,8 @@ nvk_flush_descriptors(struct nvk_cmd_buffer *cmd)
    P_NV9097_SET_CONSTANT_BUFFER_SELECTOR_C(p, root_desc_addr);
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      const struct nvk_shader *shader = &pipeline->base.shaders[stage];
-      if (shader->code_size == 0)
+      const struct nvk_shader *shader = pipeline->base.shaders[stage];
+      if (!shader || shader->code_size == 0)
          continue;
 
       uint32_t group = stage;
diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index 1618a6e1c5b0..fa976f0374c8 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -184,14 +184,15 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
    if (result != VK_SUCCESS)
       goto fail;
 
-   struct nvk_shader *shader = &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+   struct nvk_shader *shader = nvk_shader_init(dev);
+   pipeline->base.shaders[MESA_SHADER_COMPUTE] = shader;
 
    nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
 
    unsigned char sha1[SHA1_DIGEST_LENGTH];
    nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
 
-   result = nvk_compile_nir(pdev, nir, pipeline_flags, &robustness, NULL,
+   result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
                             shader);
    ralloc_free(nir);
    if (result != VK_SUCCESS)
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 8f2b621cc26d..5dc69e38af59 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -165,7 +165,6 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                              VkPipeline *pPipeline)
 {
    VK_FROM_HANDLE(vk_pipeline_layout, pipeline_layout, pCreateInfo->layout);
-   struct nvk_physical_device *pdev = nvk_device_physical(dev);
    struct nvk_graphics_pipeline *pipeline;
    VkResult result = VK_SUCCESS;
 
@@ -217,9 +216,11 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       if (sinfo == NULL)
          continue;
 
+      pipeline->base.shaders[stage] = nvk_shader_init(dev);
+
       nvk_lower_nir(dev, nir[stage], &robustness[stage],
                     state.rp->view_mask != 0, pipeline_layout,
-                    &pipeline->base.shaders[stage]);
+                    pipeline->base.shaders[stage]);
    }
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
@@ -236,14 +237,14 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       unsigned char sha1[SHA1_DIGEST_LENGTH];
       nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
 
-      result = nvk_compile_nir(pdev, nir[stage], pipeline_flags,
+      result = nvk_compile_nir(dev, nir[stage], pipeline_flags,
                                &robustness[stage], fs_key,
-                               &pipeline->base.shaders[stage]);
+                               pipeline->base.shaders[stage]);
       ralloc_free(nir[stage]);
       if (result != VK_SUCCESS)
          goto fail;
 
-      result = nvk_shader_upload(dev, &pipeline->base.shaders[stage]);
+      result = nvk_shader_upload(dev, pipeline->base.shaders[stage]);
       if (result != VK_SUCCESS)
          goto fail;
    }
@@ -256,7 +257,7 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
    struct nvk_shader *last_geom = NULL;
    for (gl_shader_stage stage = 0; stage <= MESA_SHADER_FRAGMENT; stage++) {
-      struct nvk_shader *shader = &pipeline->base.shaders[stage];
+      struct nvk_shader *shader = pipeline->base.shaders[stage];
       uint32_t idx = mesa_to_nv9097_shader_type[stage];
 
       P_IMMD(p, NV9097, SET_PIPELINE_SHADER(idx), {
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index a4ee7f8b37f3..196c8bec457f 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -33,7 +33,7 @@ nvk_pipeline_free(struct nvk_device *dev,
                   const VkAllocationCallbacks *pAllocator)
 {
    for (uint32_t s = 0; s < ARRAY_SIZE(pipeline->shaders); s++)
-      nvk_shader_finish(dev, &pipeline->shaders[s]);
+      nvk_shader_finish(dev, pipeline->shaders[s]);
 
    vk_object_free(&dev->vk, pAllocator, pipeline);
 }
@@ -131,7 +131,8 @@ nvk_GetPipelineExecutablePropertiesKHR(
                           pProperties, pExecutableCount);
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (pipeline->shaders[stage].code_size == 0)
+      const struct nvk_shader *shader = pipeline->shaders[stage];
+      if (!shader || shader->code_size == 0)
          continue;
 
       vk_outarray_append_typed(VkPipelineExecutablePropertiesKHR, &out, props) {
@@ -150,11 +151,12 @@ static struct nvk_shader *
 shader_for_exe_idx(struct nvk_pipeline *pipeline, uint32_t idx)
 {
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (pipeline->shaders[stage].code_size == 0)
+      const struct nvk_shader *shader = pipeline->shaders[stage];
+      if (!shader || shader->code_size == 0)
          continue;
 
       if (idx == 0)
-         return &pipeline->shaders[stage];
+         return pipeline->shaders[stage];
 
       idx--;
    }
diff --git a/src/nouveau/vulkan/nvk_pipeline.h b/src/nouveau/vulkan/nvk_pipeline.h
index c48bd92764b7..b7a33249ddb3 100644
--- a/src/nouveau/vulkan/nvk_pipeline.h
+++ b/src/nouveau/vulkan/nvk_pipeline.h
@@ -23,7 +23,7 @@ struct nvk_pipeline {
 
    enum nvk_pipeline_type type;
 
-   struct nvk_shader shaders[MESA_SHADER_STAGES];
+   struct nvk_shader *shaders[MESA_SHADER_STAGES];
 };
 
 VK_DEFINE_NONDISP_HANDLE_CASTS(nvk_pipeline, base, VkPipeline,
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index e4dd2b914c60..311709017d8d 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -438,13 +438,28 @@ nvk_compile_nir_with_nak(struct nvk_physical_device *pdev,
    return VK_SUCCESS;
 }
 
+struct nvk_shader *
+nvk_shader_init(struct nvk_device *dev)
+{
+   VK_MULTIALLOC(ma);
+   VK_MULTIALLOC_DECL(&ma, struct nvk_shader, shader, 1);
+
+   if (!vk_multialloc_zalloc(&ma, &dev->vk.alloc,
+                             VK_SYSTEM_ALLOCATION_SCOPE_DEVICE))
+      return NULL;
+
+   return shader;
+}
+
 VkResult
-nvk_compile_nir(struct nvk_physical_device *pdev, nir_shader *nir,
+nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
                 const struct nak_fs_key *fs_key,
                 struct nvk_shader *shader)
 {
+   struct nvk_physical_device *pdev = nvk_device_physical(dev);
+
    if (use_nak(pdev, nir->info.stage)) {
       return nvk_compile_nir_with_nak(pdev, nir, pipeline_flags, rs,
                                       fs_key, shader);
@@ -505,6 +520,9 @@ nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader)
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
 {
+   if (shader == NULL)
+      return;
+
    if (shader->upload_size > 0) {
       nvk_heap_free(dev, &dev->shader_heap,
                     shader->upload_addr,
@@ -513,6 +531,7 @@ nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
 
    if (shader->nak)
       nak_shader_bin_destroy(shader->nak);
+   vk_free(&dev->vk.alloc, shader);
 }
 
 void
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index d8b019bece91..01b54bd1122c 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -67,7 +67,7 @@ nvk_shader_address(const struct nvk_shader *shader)
 static inline bool
 nvk_shader_is_enabled(const struct nvk_shader *shader)
 {
-   return shader->upload_size > 0;
+   return shader && shader->upload_size > 0;
 }
 
 VkShaderStageFlags nvk_nak_stages(const struct nv_device_info *info);
@@ -118,7 +118,7 @@ nvk_lower_nir(struct nvk_device *dev, nir_shader *nir,
               struct nvk_shader *shader);
 
 VkResult
-nvk_compile_nir(struct nvk_physical_device *dev, nir_shader *nir,
+nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
                 const struct nak_fs_key *fs_key,
@@ -127,6 +127,9 @@ nvk_compile_nir(struct nvk_physical_device *dev, nir_shader *nir,
 VkResult
 nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
 
+struct nvk_shader *
+nvk_shader_init(struct nvk_device *dev);
+
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader);
 
-- 
GitLab


From aea9a84bb5a55aac0c4816ad9b8ed5cf83ff8942 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 18 Oct 2023 23:55:36 +0200
Subject: [PATCH 4/8] nvk: pipeline shader cache

dEQP-VK.pipeline.monolithic.cache.*

Test run totals:
  Passed:        773/773 (100.0%)
  Failed:        0/773 (0.0%)
  Not supported: 0/773 (0.0%)
  Warnings:      0/773 (0.0%)
  Waived:        0/773 (0.0%)

Timing these test:
Before:
real    0m11,304s
user    0m9,442s
sys     0m0,477s

After:
real    0m3,470s
user    0m1,962s
sys     0m0,504s
---
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  54 ++++++++---
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  80 ++++++++++++----
 src/nouveau/vulkan/nvk_pipeline.c          |   3 -
 src/nouveau/vulkan/nvk_shader.c            | 105 ++++++++++++++++++++-
 src/nouveau/vulkan/nvk_shader.h            |  13 ++-
 5 files changed, 217 insertions(+), 38 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index fa976f0374c8..2d1c08b0d172 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -178,26 +178,54 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
                                      pCreateInfo->pNext,
                                      pCreateInfo->stage.pNext);
 
-   nir_shader *nir;
-   result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
-                                    cache, NULL, &nir);
-   if (result != VK_SUCCESS)
-      goto fail;
+   unsigned char sha1[SHA1_DIGEST_LENGTH];
+   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness,
+                   pipeline_layout, NULL);
 
-   struct nvk_shader *shader = nvk_shader_init(dev);
-   pipeline->base.shaders[MESA_SHADER_COMPUTE] = shader;
+   bool cache_hit = false;
+   struct vk_pipeline_cache_object *cache_obj = NULL;
 
-   nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
+   if (cache) {
+      cache_obj = vk_pipeline_cache_lookup_object(cache, &sha1, sizeof(sha1),
+                                                  &nvk_shader_ops, &cache_hit);
+      pipeline->base.shaders[MESA_SHADER_COMPUTE] =
+         container_of(cache_obj, struct nvk_shader, base);
+      result = VK_SUCCESS;
+   }
 
-   unsigned char sha1[SHA1_DIGEST_LENGTH];
-   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
+   if (!cache_obj) {
+      nir_shader *nir;
+      result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
+                                       cache, NULL, &nir);
+      if (result != VK_SUCCESS)
+         goto fail;
+
+      struct nvk_shader *shader = nvk_shader_init(dev, sha1, SHA1_DIGEST_LENGTH);
+      if(shader == NULL)
+         return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+      nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
+
+      result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL, cache, shader);
+
+      if (result == VK_SUCCESS) {
+         cache_obj = &shader->base;
+
+         if (cache)
+            cache_obj = vk_pipeline_cache_add_object(cache, cache_obj);
+
+         pipeline->base.shaders[MESA_SHADER_COMPUTE] =
+            container_of(cache_obj, struct nvk_shader, base);
+      }
+
+      ralloc_free(nir);
+   }
 
-   result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
-                            shader);
-   ralloc_free(nir);
    if (result != VK_SUCCESS)
       goto fail;
 
+   struct nvk_shader *shader = container_of(cache_obj, struct nvk_shader, base);
+
    result = nvk_shader_upload(dev, shader);
    if (result != VK_SUCCESS)
       goto fail;
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 5dc69e38af59..98158a31c611 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -186,6 +186,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
 
+   struct vk_pipeline_cache_object *cache_objs[MESA_SHADER_STAGES] = {};
+
+   struct nak_fs_key fs_key_tmp, *fs_key = NULL;
+   nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
+   fs_key = &fs_key_tmp;
+
    for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
       const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
       gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
@@ -199,6 +205,32 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
       vk_pipeline_robustness_state_fill(&dev->vk, &robustness[stage],
                                         pCreateInfo->pNext, sinfo->pNext);
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
+
+      unsigned char sha1[SHA1_DIGEST_LENGTH];
+      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
+                      stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
+
+      if (cache) {
+         bool cache_hit = false;
+         cache_objs[stage] = vk_pipeline_cache_lookup_object(cache, &sha1, sizeof(sha1),
+                                                             &nvk_shader_ops, &cache_hit);
+         if (cache_objs[stage]) {
+            pipeline->base.shaders[stage] =
+               container_of(cache_objs[stage], struct nvk_shader, base);
+         }
+      }
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL || cache_objs[stage])
+         continue;
 
       result = nvk_shader_stage_to_nir(dev, sinfo, &robustness[stage],
                                        cache, NULL, &nir[stage]);
@@ -216,31 +248,39 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       if (sinfo == NULL)
          continue;
 
-      pipeline->base.shaders[stage] = nvk_shader_init(dev);
+      if (!cache_objs[stage]) {
+         unsigned char sha1[SHA1_DIGEST_LENGTH];
+         nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
+                         stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
 
-      nvk_lower_nir(dev, nir[stage], &robustness[stage],
-                    state.rp->view_mask != 0, pipeline_layout,
-                    pipeline->base.shaders[stage]);
-   }
+         struct nvk_shader *shader = nvk_shader_init(dev, sha1, SHA1_DIGEST_LENGTH);
+         if(shader == NULL) {
+            result = vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
+            goto fail;
+         }
 
-   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
-      if (sinfo == NULL)
-         continue;
+         nvk_lower_nir(dev, nir[stage], &robustness[stage],
+                       state.rp->view_mask != 0, pipeline_layout, shader);
 
-      struct nak_fs_key fs_key_tmp, *fs_key = NULL;
-      if (stage == MESA_SHADER_FRAGMENT) {
-         nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
-         fs_key = &fs_key_tmp;
-      }
+         result = nvk_compile_nir(dev, nir[stage],
+                                  pipeline_flags, &robustness[stage],
+                                  stage == MESA_SHADER_FRAGMENT ? fs_key : NULL,
+                                  cache, shader);
 
-      unsigned char sha1[SHA1_DIGEST_LENGTH];
-      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
+         if (result == VK_SUCCESS) {
+            cache_objs[stage] = &shader->base;
+
+            if (cache)
+               cache_objs[stage] = vk_pipeline_cache_add_object(cache,
+                                                                cache_objs[stage]);
+
+            pipeline->base.shaders[stage] =
+               container_of(cache_objs[stage], struct nvk_shader, base);
+         }
+
+         ralloc_free(nir[stage]);
+      }
 
-      result = nvk_compile_nir(dev, nir[stage], pipeline_flags,
-                               &robustness[stage], fs_key,
-                               pipeline->base.shaders[stage]);
-      ralloc_free(nir[stage]);
       if (result != VK_SUCCESS)
          goto fail;
 
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index 196c8bec457f..2a467448553b 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -32,9 +32,6 @@ nvk_pipeline_free(struct nvk_device *dev,
                   struct nvk_pipeline *pipeline,
                   const VkAllocationCallbacks *pAllocator)
 {
-   for (uint32_t s = 0; s < ARRAY_SIZE(pipeline->shaders); s++)
-      nvk_shader_finish(dev, pipeline->shaders[s]);
-
    vk_object_free(&dev->vk, pAllocator, pipeline);
 }
 
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index 311709017d8d..dd7fec94b330 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -439,15 +439,21 @@ nvk_compile_nir_with_nak(struct nvk_physical_device *pdev,
 }
 
 struct nvk_shader *
-nvk_shader_init(struct nvk_device *dev)
+nvk_shader_init(struct nvk_device *dev, const void *key_data, size_t key_size)
 {
    VK_MULTIALLOC(ma);
    VK_MULTIALLOC_DECL(&ma, struct nvk_shader, shader, 1);
+   VK_MULTIALLOC_DECL_SIZE(&ma, char, obj_key_data, key_size);
 
    if (!vk_multialloc_zalloc(&ma, &dev->vk.alloc,
                              VK_SYSTEM_ALLOCATION_SCOPE_DEVICE))
       return NULL;
 
+   memcpy(obj_key_data, key_data, key_size);
+
+   vk_pipeline_cache_object_init(&dev->vk, &shader->base,
+                                 &nvk_shader_ops, obj_key_data, key_size);
+
    return shader;
 }
 
@@ -456,6 +462,7 @@ nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
                 const struct nak_fs_key *fs_key,
+                struct vk_pipeline_cache *cache,
                 struct nvk_shader *shader)
 {
    struct nvk_physical_device *pdev = nvk_device_physical(dev);
@@ -566,3 +573,99 @@ nvk_hash_shader(unsigned char *hash,
 
    _mesa_sha1_final(&ctx, hash);
 }
+
+static bool
+nvk_shader_serialize(struct vk_pipeline_cache_object *object,
+                     struct blob *blob);
+
+static struct vk_pipeline_cache_object *
+nvk_shader_deserialize(struct vk_pipeline_cache *cache,
+                       const void *key_data,
+                       size_t key_size,
+                       struct blob_reader *blob);
+
+void
+nvk_shader_destroy(struct vk_device *_dev,
+                   struct vk_pipeline_cache_object *object)
+{
+   struct nvk_device *dev =
+      container_of(_dev, struct nvk_device, vk);
+   struct nvk_shader *shader =
+      container_of(object, struct nvk_shader, base);
+
+   nvk_shader_finish(dev, shader);
+}
+
+const struct vk_pipeline_cache_object_ops nvk_shader_ops = {
+   .serialize = nvk_shader_serialize,
+   .deserialize = nvk_shader_deserialize,
+   .destroy = nvk_shader_destroy,
+};
+
+static bool
+nvk_shader_serialize(struct vk_pipeline_cache_object *object,
+                     struct blob *blob)
+{
+   struct nvk_shader *shader =
+      container_of(object, struct nvk_shader, base);
+
+   blob_write_bytes(blob, &shader->info, sizeof(shader->info));
+   blob_write_bytes(blob, &shader->cbuf_map, sizeof(shader->cbuf_map));
+   blob_write_uint32(blob, shader->code_size);
+   blob_write_bytes(blob, shader->code_ptr, shader->code_size);
+   if (shader->nak) {
+      blob_write_uint8(blob, 1);
+      blob_write_bytes(blob, shader->nak, sizeof(struct nak_shader_bin));
+      blob_write_string(blob, shader->nak->asm_str ? shader->nak->asm_str : "\n");
+   } else {
+      blob_write_uint8(blob, 0);
+   }
+
+   return true;
+}
+
+static struct vk_pipeline_cache_object *
+nvk_shader_deserialize(struct vk_pipeline_cache *cache,
+                       const void *key_data,
+                       size_t key_size,
+                       struct blob_reader *blob)
+{
+   struct nvk_device *dev =
+      container_of(cache->base.device, struct nvk_device, vk);
+   struct nvk_shader *shader =
+      nvk_shader_init(dev, key_data, key_size);
+
+   if (!shader)
+      return NULL;
+
+   blob_copy_bytes(blob, &shader->info, sizeof(shader->info));
+   blob_copy_bytes(blob, &shader->cbuf_map, sizeof(shader->cbuf_map));
+
+   shader->code_size = blob_read_uint32(blob);
+   void *code_ptr = malloc(shader->code_size);
+   if (!code_ptr)
+      goto fail;
+
+   blob_copy_bytes(blob, code_ptr, shader->code_size);
+   shader->code_ptr = code_ptr;
+
+   bool is_nak = blob_read_uint8(blob);
+   if (is_nak) {
+      shader->nak = malloc(sizeof(struct nak_shader_bin));
+      if(!shader->nak)
+         goto fail;
+      blob_copy_bytes(blob, shader->nak, sizeof(struct nak_shader_bin));
+
+      shader->nak->info = shader->info;
+      shader->nak->code = shader->code_ptr;
+      shader->nak->code_size = shader->code_size;
+      shader->nak->asm_str = strdup(blob_read_string(blob));
+   }
+
+   return &shader->base;
+
+fail:
+   /* nvk_shader_destroy frees both shader and shader->xfb */
+   nvk_shader_destroy(cache->base.device, &shader->base);
+   return NULL;
+}
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index 01b54bd1122c..fc88e154c6a5 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -8,6 +8,8 @@
 #include "nvk_private.h"
 #include "nvk_device_memory.h"
 
+#include "vk_pipeline_cache.h"
+
 #include "nak.h"
 #include "nir.h"
 #include "nouveau_bo.h"
@@ -46,6 +48,8 @@ struct nvk_cbuf_map {
 };
 
 struct nvk_shader {
+   struct vk_pipeline_cache_object base;
+
    struct nak_shader_info info;
    struct nvk_cbuf_map cbuf_map;
 
@@ -122,13 +126,16 @@ nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
                 const struct nak_fs_key *fs_key,
+                struct vk_pipeline_cache *cache,
                 struct nvk_shader *shader);
 
 VkResult
 nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
 
 struct nvk_shader *
-nvk_shader_init(struct nvk_device *dev);
+nvk_shader_init(struct nvk_device *dev, const void *key_data, size_t key_size);
+
+extern const struct vk_pipeline_cache_object_ops nvk_shader_ops;
 
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader);
@@ -140,6 +147,10 @@ nvk_hash_shader(unsigned char *hash,
                  const struct vk_pipeline_layout *layout,
                  const struct nak_fs_key *fs_key);
 
+void
+nvk_shader_destroy(struct vk_device *dev,
+                   struct vk_pipeline_cache_object *object);
+
 /* Codegen wrappers.
  *
  * TODO: Delete these once NAK supports everything.
-- 
GitLab


From 2ee48f3e0d9fa781de784ab4f53d491fbac0e47b Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Mon, 23 Oct 2023 21:29:18 +0200
Subject: [PATCH 5/8] nvk: VK_EXT_pipeline_creation_feedback

dEQP-VK.*creation_feedback*

Test run totals:
  Passed:        13/73 (17.8%)
  Failed:        0/73 (0.0%)
  Not supported: 60/73 (82.2%)
  Warnings:      0/73 (0.0%)
  Waived:        0/73 (0.0%)
---
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 41 +++++++++++++++++++---
 src/nouveau/vulkan/nvk_physical_device.c   |  1 +
 2 files changed, 38 insertions(+), 4 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 98158a31c611..e19d6d654719 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -182,6 +182,17 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                             NULL, 0, &all, NULL, 0, NULL);
    assert(result == VK_SUCCESS);
 
+   VkPipelineCreationFeedbackEXT pipeline_feedback = {
+      .flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
+   };
+   VkPipelineCreationFeedbackEXT stage_feedbacks[MESA_SHADER_STAGES] = { 0 };
+
+   int64_t pipeline_start = os_time_get_nano();
+
+   const VkPipelineCreationFeedbackCreateInfo *creation_feedback =
+         vk_find_struct_const(pCreateInfo->pNext,
+                              PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
+
    const VkPipelineShaderStageCreateInfo *infos[MESA_SHADER_STAGES] = {};
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
@@ -220,10 +231,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
          bool cache_hit = false;
          cache_objs[stage] = vk_pipeline_cache_lookup_object(cache, &sha1, sizeof(sha1),
                                                              &nvk_shader_ops, &cache_hit);
-         if (cache_objs[stage]) {
-            pipeline->base.shaders[stage] =
-               container_of(cache_objs[stage], struct nvk_shader, base);
-         }
+         pipeline->base.shaders[stage] =
+            container_of(cache_objs[stage], struct nvk_shader, base);
+
+         if (cache_hit && cache != dev->mem_cache)
+            pipeline_feedback.flags |=
+               VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
       }
    }
 
@@ -249,6 +262,8 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
          continue;
 
       if (!cache_objs[stage]) {
+         int64_t stage_start = os_time_get_nano();
+
          unsigned char sha1[SHA1_DIGEST_LENGTH];
          nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
                          stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
@@ -274,10 +289,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                cache_objs[stage] = vk_pipeline_cache_add_object(cache,
                                                                 cache_objs[stage]);
 
+            stage_feedbacks[stage].flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT;
             pipeline->base.shaders[stage] =
                container_of(cache_objs[stage], struct nvk_shader, base);
          }
 
+         stage_feedbacks[stage].duration += os_time_get_nano() - stage_start;
          ralloc_free(nir[stage]);
       }
 
@@ -414,6 +431,22 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
    pipeline->dynamic.ms.sample_locations = &pipeline->_dynamic_sl;
    vk_dynamic_graphics_state_fill(&pipeline->dynamic, &state);
 
+   pipeline_feedback.duration = os_time_get_nano() - pipeline_start;
+   if (creation_feedback) {
+      *creation_feedback->pPipelineCreationFeedback = pipeline_feedback;
+
+      int fb_count = creation_feedback->pipelineStageCreationFeedbackCount;
+      if (pCreateInfo->stageCount == fb_count) {
+         for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
+            const VkPipelineShaderStageCreateInfo *sinfo =
+               &pCreateInfo->pStages[i];
+            gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+            creation_feedback->pPipelineStageCreationFeedbacks[i] =
+               stage_feedbacks[stage];
+         }
+      }
+   }
+
    *pPipeline = nvk_pipeline_to_handle(&pipeline->base);
 
    return VK_SUCCESS;
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 103e0e7c56bb..273d782a066b 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -174,6 +174,7 @@ nvk_get_device_extensions(const struct nvk_instance *instance,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
       .EXT_pci_bus_info = info->type == NV_DEVICE_TYPE_DIS,
+      .EXT_pipeline_creation_feedback = true,
       .EXT_physical_device_drm = true,
       .EXT_primitive_topology_list_restart = true,
       .EXT_private_data = true,
-- 
GitLab


From 2a26d206aafc932dbf4b632dfeca391cbfa3dcd0 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Fri, 6 Oct 2023 20:15:21 +0200
Subject: [PATCH 6/8] nvk: VK_EXT_pipeline_creation_cache_control

dEQP-VK.pipeline.monolithic.creation_cache_control.*

Test run totals:
  Passed:        16/18 (88.9%)
  Failed:        0/18 (0.0%)
  Not supported: 2/18 (11.1%)
  Warnings:      0/18 (0.0%)
  Waived:        0/18 (0.0%)
---
 src/nouveau/vulkan/nvk_compute_pipeline.c  | 6 ++++++
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 6 ++++++
 src/nouveau/vulkan/nvk_physical_device.c   | 2 ++
 3 files changed, 14 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index 2d1c08b0d172..dfd58ff3e4e4 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -194,6 +194,12 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
    }
 
    if (!cache_obj) {
+      if (pCreateInfo->flags &
+          VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
+         result = VK_PIPELINE_COMPILE_REQUIRED;
+         goto fail;
+      }
+
       nir_shader *nir;
       result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
                                        cache, NULL, &nir);
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index e19d6d654719..f0ef7daca1d3 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -238,6 +238,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
             pipeline_feedback.flags |=
                VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
       }
+
+      if (!cache_objs[stage] &&
+          pCreateInfo->flags & VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
+         result = VK_PIPELINE_COMPILE_REQUIRED;
+         goto fail;
+      }
    }
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 273d782a066b..0a520a0777cd 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -174,6 +174,7 @@ nvk_get_device_extensions(const struct nvk_instance *instance,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
       .EXT_pci_bus_info = info->type == NV_DEVICE_TYPE_DIS,
+      .EXT_pipeline_creation_cache_control = true,
       .EXT_pipeline_creation_feedback = true,
       .EXT_physical_device_drm = true,
       .EXT_primitive_topology_list_restart = true,
@@ -325,6 +326,7 @@ nvk_get_device_features(const struct nv_device_info *info,
       .robustImageAccess = true,
       .inlineUniformBlock = true,
       .descriptorBindingInlineUniformBlockUpdateAfterBind = true,
+      .pipelineCreationCacheControl = true,
       .privateData = true,
       .shaderDemoteToHelperInvocation = true,
       .shaderTerminateInvocation = true,
-- 
GitLab


From afb89407e54a4a77343bb289a02fc28570f87f2e Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Mon, 23 Oct 2023 23:03:52 +0200
Subject: [PATCH 7/8] nvk: VK_EXT_shader_module_identifier

dEQP-VK.pipeline.monolithic.shader_module_identifier.*

Test run totals:
  Passed:        530/1292 (41.0%)
  Failed:        0/1292 (0.0%)
  Not supported: 762/1292 (59.0%)
  Warnings:      0/1292 (0.0%)
  Waived:        0/1292 (0.0%)
---
 src/nouveau/vulkan/nvk_physical_device.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 0a520a0777cd..a9ef92e3106d 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -18,6 +18,7 @@
 
 #include "vulkan/runtime/vk_device.h"
 #include "vulkan/runtime/vk_drm_syncobj.h"
+#include "vulkan/runtime/vk_shader_module.h"
 #include "vulkan/wsi/wsi_common.h"
 
 #include <sys/stat.h>
@@ -189,6 +190,7 @@ nvk_get_device_extensions(const struct nvk_instance *instance,
       .EXT_shader_image_atomic_int64 = info->cls_eng3d >= MAXWELL_A &&
                                        nvk_use_nak(info),
       .EXT_shader_demote_to_helper_invocation = true,
+      .EXT_shader_module_identifier = true,
       .EXT_shader_subgroup_ballot = true,
       .EXT_shader_subgroup_vote = true,
       .EXT_shader_viewport_index_layer = info->cls_eng3d >= MAXWELL_B,
@@ -492,6 +494,9 @@ nvk_get_device_features(const struct nv_device_info *info,
       .sparseImageInt64Atomics = info->cls_eng3d >= MAXWELL_A &&
                                  nvk_use_nak(info),
 
+      /* VK_EXT_shader_module_identifier */
+      .shaderModuleIdentifier = true,
+
       /* VK_EXT_texel_buffer_alignment */
       .texelBufferAlignment = true,
 
@@ -815,6 +820,13 @@ nvk_get_device_properties(const struct nvk_instance *instance,
    snprintf(properties->deviceName, sizeof(properties->deviceName),
             "%s", info->device_name);
 
+   /* VK_EXT_shader_module_identifier */
+   STATIC_ASSERT(sizeof(vk_shaderModuleIdentifierAlgorithmUUID) ==
+      sizeof(properties->shaderModuleIdentifierAlgorithmUUID));
+   memcpy(properties->shaderModuleIdentifierAlgorithmUUID,
+            vk_shaderModuleIdentifierAlgorithmUUID,
+            sizeof(properties->shaderModuleIdentifierAlgorithmUUID));
+
    const struct {
       uint16_t vendor_id;
       uint16_t device_id;
-- 
GitLab


From 2235fdf7161abbea0801d15ffc371f5d5e47e6cb Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Thu, 4 Jan 2024 03:01:38 +0100
Subject: [PATCH 8/8] docs: update features.txt for nvk

Advertise:
VK_EXT_pipeline_creation_cache_control
VK_EXT_pipeline_creation_feedback
VK_EXT_shader_module_identifier
---
 docs/features.txt | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/docs/features.txt b/docs/features.txt
index 367ebd4a6897..acc038e3565b 100644
--- a/docs/features.txt
+++ b/docs/features.txt
@@ -488,8 +488,8 @@ Vulkan 1.3 -- all DONE: anv, radv, tu, lvp, vn
   VK_EXT_extended_dynamic_state                         DONE (anv, hasvk, lvp, nvk, radv, tu, vn)
   VK_EXT_extended_dynamic_state2                        DONE (anv, hasvk, lvp, nvk, radv, tu, vn)
   VK_EXT_inline_uniform_block                           DONE (anv, hasvk, lvp, nvk, radv, tu, v3dv, vn)
-  VK_EXT_pipeline_creation_cache_control                DONE (anv, hasvk, lvp, radv, tu, v3dv, vn)
-  VK_EXT_pipeline_creation_feedback                     DONE (anv, hasvk, lvp, radv, tu, v3dv, vn)
+  VK_EXT_pipeline_creation_cache_control                DONE (anv, hasvk, lvp, nvk, radv, tu, v3dv, vn)
+  VK_EXT_pipeline_creation_feedback                     DONE (anv, hasvk, lvp, nvk, radv, tu, v3dv, vn)
   VK_EXT_private_data                                   DONE (anv, hasvk, lvp, nvk, pvr, radv, tu, v3dv, vn)
   VK_EXT_image_robustness                               DONE (anv, hasvk, lvp, nvk, radv, tu, v3dv, vn)
   VK_EXT_shader_demote_to_helper_invocation             DONE (anv, hasvk, lvp, nvk, radv, tu, vn)
@@ -611,7 +611,7 @@ Khronos extensions that are not part of any Vulkan version:
   VK_EXT_shader_stencil_export                          DONE (anv/gen9+, lvp, radv, tu, vn)
   VK_EXT_shader_subgroup_ballot                         DONE (anv, dzn, hasvk, lvp, nvk, radv, vn)
   VK_EXT_shader_subgroup_vote                           DONE (anv, dzn, hasvk, lvp, nvk, radv)
-  VK_EXT_shader_module_identifier                       DONE (anv, hasvk, radv, tu, v3dv)
+  VK_EXT_shader_module_identifier                       DONE (anv, hasvk, nvk, radv, tu, v3dv)
   VK_EXT_transform_feedback                             DONE (anv, hasvk, lvp, nvk, radv, tu, vn)
   VK_EXT_vertex_attribute_divisor                       DONE (anv, dzn, hasvk, lvp, nvk, panvk, radv, tu, v3dv, vn)
   VK_EXT_vertex_input_dynamic_state                     DONE (anv, lvp, nvk, radv, tu, vn)
-- 
GitLab

