From 63f8b01bff61c9d1c6be8c125fdf15ff8bb1ad55 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 4 Oct 2023 20:37:40 +0200
Subject: [PATCH 01/10] nvk: loop over stages in MESA order

we do this to make the VkPipelineShaderStageCreateInfo available
when we want to calculate the shader hash
---
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 8485818fcd3..65795410865 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -183,12 +183,20 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                             NULL, 0, &all, NULL, 0, NULL);
    assert(result == VK_SUCCESS);
 
+   const VkPipelineShaderStageCreateInfo *infos[MESA_SHADER_STAGES] = {};
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
 
    for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
       const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
       gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+      infos[stage] = sinfo;
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
 
       vk_pipeline_robustness_state_fill(&dev->vk, &robustness[stage],
                                         pCreateInfo->pNext, sinfo->pNext);
@@ -204,16 +212,19 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       merge_tess_info(&nir[MESA_SHADER_TESS_EVAL]->info, &nir[MESA_SHADER_TESS_CTRL]->info);
    }
 
-   for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
-      const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
-      gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
+
       nvk_lower_nir(dev, nir[stage], &robustness[stage],
                     state.rp->view_mask != 0, pipeline_layout,
                     &pipeline->base.shaders[stage]);
    }
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (nir[stage] == NULL)
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
          continue;
 
       struct nak_fs_key fs_key_tmp, *fs_key = NULL;
-- 
2.43.0


From b8d829fc65b900131f69088f6233071d34d5f568 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 4 Oct 2023 20:38:01 +0200
Subject: [PATCH 02/10] nvk: add hashing for shaders

---
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  3 ++
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  3 ++
 src/nouveau/vulkan/nvk_shader.c            | 33 ++++++++++++++++++++++
 src/nouveau/vulkan/nvk_shader.h            | 23 ++++-----------
 4 files changed, 45 insertions(+), 17 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index a74b3765aa1..1618a6e1c5b 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -188,6 +188,9 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
 
    nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
 
+   unsigned char sha1[SHA1_DIGEST_LENGTH];
+   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
+
    result = nvk_compile_nir(pdev, nir, pipeline_flags, &robustness, NULL,
                             shader);
    ralloc_free(nir);
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 65795410865..8f2b621cc26 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -233,6 +233,9 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
          fs_key = &fs_key_tmp;
       }
 
+      unsigned char sha1[SHA1_DIGEST_LENGTH];
+      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
+
       result = nvk_compile_nir(pdev, nir[stage], pipeline_flags,
                                &robustness[stage], fs_key,
                                &pipeline->base.shaders[stage]);
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index 329594cb852..c79202c427b 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -513,3 +513,36 @@ nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
    if (shader->nak)
       nak_shader_bin_destroy(shader->nak);
 }
+
+void
+nvk_hash_shader(unsigned char *hash,
+                const VkPipelineShaderStageCreateInfo *sinfo,
+                const struct vk_pipeline_robustness_state *rstate,
+                const struct vk_pipeline_layout *layout,
+                const struct nvk_fs_key *fs_key)
+{
+   struct mesa_sha1 ctx;
+
+   _mesa_sha1_init(&ctx);
+
+   unsigned char stage_sha1[SHA1_DIGEST_LENGTH];
+   vk_pipeline_hash_shader_stage(sinfo, rstate, stage_sha1);
+
+   _mesa_sha1_update(&ctx, stage_sha1, sizeof(stage_sha1));
+
+   if (layout) {
+      _mesa_sha1_update(&ctx, &layout->create_flags,
+                        sizeof(layout->create_flags));
+      _mesa_sha1_update(&ctx, &layout->set_count, sizeof(layout->set_count));
+      for (int i = 0; i < layout->set_count; i++) {
+         struct nvk_descriptor_set_layout *set =
+            vk_to_nvk_descriptor_set_layout(layout->set_layouts[i]);
+         _mesa_sha1_update(&ctx, &set->sha1, sizeof(set->sha1));
+      }
+   }
+
+   if(fs_key)
+      _mesa_sha1_update(&ctx, fs_key, sizeof(*fs_key));
+
+   _mesa_sha1_final(&ctx, hash);
+}
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index dea5cdf0bd6..556d8104852 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -130,22 +130,11 @@ nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader);
 
-/* Codegen wrappers.
- *
- * TODO: Delete these once NAK supports everything.
- */
-uint64_t nvk_cg_get_prog_debug(void);
-uint64_t nvk_cg_get_prog_optimize(void);
-
-const nir_shader_compiler_options *
-nvk_cg_nir_options(const struct nvk_physical_device *pdev,
-                   gl_shader_stage stage);
-
-void nvk_cg_preprocess_nir(nir_shader *nir);
-void nvk_cg_optimize_nir(nir_shader *nir);
-
-VkResult nvk_cg_compile_nir(struct nvk_physical_device *pdev, nir_shader *nir,
-                            const struct nak_fs_key *fs_key,
-                            struct nvk_shader *shader);
+void
+nvk_hash_shader(unsigned char *hash,
+                 const VkPipelineShaderStageCreateInfo *sinfo,
+                 const struct vk_pipeline_robustness_state *rstate,
+                 const struct vk_pipeline_layout *layout,
+                 const struct nvk_fs_key *fs_key);
 
 #endif
-- 
2.43.0


From 81907199aeda7f7deaa7fd14c0fb1918b7a10d60 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Tue, 17 Oct 2023 02:08:33 +0200
Subject: [PATCH 03/10] nvk: allocatable nvk_shaders

This will be needed later when the shader life cycle will be managed
by the pipeline cache
---
 src/nouveau/vulkan/nvk_cmd_buffer.c        |  2 +
 src/nouveau/vulkan/nvk_cmd_dispatch.c      |  2 +-
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  4 +-
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 15 +++++---
 src/nouveau/vulkan/nvk_pipeline.c          |  2 +-
 src/nouveau/vulkan/nvk_pipeline.h          |  2 +-
 src/nouveau/vulkan/nvk_shader.c            | 44 +++++++++++++++++-----
 src/nouveau/vulkan/nvk_shader.h            |  6 +--
 8 files changed, 54 insertions(+), 23 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_cmd_buffer.c b/src/nouveau/vulkan/nvk_cmd_buffer.c
index 53327917092..e763295df64 100644
--- a/src/nouveau/vulkan/nvk_cmd_buffer.c
+++ b/src/nouveau/vulkan/nvk_cmd_buffer.c
@@ -537,6 +537,8 @@ nvk_CmdBindPipeline(VkCommandBuffer commandBuffer,
    struct nvk_device *dev = nvk_cmd_buffer_device(cmd);
 
    for (unsigned s = 0; s < ARRAY_SIZE(pipeline->shaders); s++) {
+      if (!pipeline->shaders[s])
+         continue;
       if (pipeline->shaders[s].info.slm_size)
          nvk_device_ensure_slm(dev, pipeline->shaders[s].info.slm_size);
    }
diff --git a/src/nouveau/vulkan/nvk_cmd_dispatch.c b/src/nouveau/vulkan/nvk_cmd_dispatch.c
index 5708c815da6..2ca1e9daca1 100644
--- a/src/nouveau/vulkan/nvk_cmd_dispatch.c
+++ b/src/nouveau/vulkan/nvk_cmd_dispatch.c
@@ -148,7 +148,7 @@ nvk_compute_local_size(struct nvk_cmd_buffer *cmd)
 {
    const struct nvk_compute_pipeline *pipeline = cmd->state.cs.pipeline;
    const struct nvk_shader *shader =
-      &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+      pipeline->base.shaders[MESA_SHADER_COMPUTE];
 
    return shader->info.cs.local_size[0] *
           shader->info.cs.local_size[1] *
diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index 1618a6e1c5b..eb3413d2eb5 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -184,14 +184,14 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
    if (result != VK_SUCCESS)
       goto fail;
 
-   struct nvk_shader *shader = &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+   struct nvk_shader *shader = pipeline->base.shaders[MESA_SHADER_COMPUTE];
 
    nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
 
    unsigned char sha1[SHA1_DIGEST_LENGTH];
    nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
 
-   result = nvk_compile_nir(pdev, nir, pipeline_flags, &robustness, NULL,
+   result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
                             shader);
    ralloc_free(nir);
    if (result != VK_SUCCESS)
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 8f2b621cc26..29c442ee930 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -165,7 +165,6 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                              VkPipeline *pPipeline)
 {
    VK_FROM_HANDLE(vk_pipeline_layout, pipeline_layout, pCreateInfo->layout);
-   struct nvk_physical_device *pdev = nvk_device_physical(dev);
    struct nvk_graphics_pipeline *pipeline;
    VkResult result = VK_SUCCESS;
 
@@ -236,14 +235,14 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       unsigned char sha1[SHA1_DIGEST_LENGTH];
       nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
 
-      result = nvk_compile_nir(pdev, nir[stage], pipeline_flags,
+      result = nvk_compile_nir(dev, nir[stage], pipeline_flags,
                                &robustness[stage], fs_key,
                                &pipeline->base.shaders[stage]);
       ralloc_free(nir[stage]);
       if (result != VK_SUCCESS)
          goto fail;
 
-      result = nvk_shader_upload(dev, &pipeline->base.shaders[stage]);
+      result = nvk_shader_upload(dev, pipeline->base.shaders[stage]);
       if (result != VK_SUCCESS)
          goto fail;
    }
@@ -256,15 +255,19 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
    struct nvk_shader *last_geom = NULL;
    for (gl_shader_stage stage = 0; stage <= MESA_SHADER_FRAGMENT; stage++) {
-      struct nvk_shader *shader = &pipeline->base.shaders[stage];
+      struct nvk_shader *shader = pipeline->base.shaders[stage];
+      uint32_t upload_size = 0;
+      if (shader)
+         upload_size = shader->upload_size;
+
       uint32_t idx = mesa_to_nv9097_shader_type[stage];
 
       P_IMMD(p, NV9097, SET_PIPELINE_SHADER(idx), {
-         .enable  = nvk_shader_is_enabled(shader),
+         .enable  = upload_size > 0,
          .type    = mesa_to_nv9097_shader_type[stage],
       });
 
-      if (!nvk_shader_is_enabled(shader))
+      if (!shader || !nvk_shader_is_enabled(shader))
          continue;
 
       if (stage != MESA_SHADER_FRAGMENT)
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index a4ee7f8b37f..29519e6c281 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -33,7 +33,7 @@ nvk_pipeline_free(struct nvk_device *dev,
                   const VkAllocationCallbacks *pAllocator)
 {
    for (uint32_t s = 0; s < ARRAY_SIZE(pipeline->shaders); s++)
-      nvk_shader_finish(dev, &pipeline->shaders[s]);
+      nvk_shader_finish(dev, pipeline->shaders[s]);
 
    vk_object_free(&dev->vk, pAllocator, pipeline);
 }
diff --git a/src/nouveau/vulkan/nvk_pipeline.h b/src/nouveau/vulkan/nvk_pipeline.h
index c48bd92764b..b7a33249ddb 100644
--- a/src/nouveau/vulkan/nvk_pipeline.h
+++ b/src/nouveau/vulkan/nvk_pipeline.h
@@ -23,7 +23,7 @@ struct nvk_pipeline {
 
    enum nvk_pipeline_type type;
 
-   struct nvk_shader shaders[MESA_SHADER_STAGES];
+   struct nvk_shader *shaders[MESA_SHADER_STAGES];
 };
 
 VK_DEFINE_NONDISP_HANDLE_CASTS(nvk_pipeline, base, VkPipeline,
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index c79202c427b..25047f5fb98 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -437,19 +437,40 @@ nvk_compile_nir_with_nak(struct nvk_physical_device *pdev,
    return VK_SUCCESS;
 }
 
+static struct nvk_shader *
+nvk_shader_init(struct nvk_device *dev)
+{
+   VK_MULTIALLOC(ma);
+   VK_MULTIALLOC_DECL(&ma, struct nvk_shader, shader, 1);
+
+   if (!vk_multialloc_zalloc(&ma, &dev->vk.alloc,
+                             VK_SYSTEM_ALLOCATION_SCOPE_DEVICE))
+      return NULL;
+
+   return shader;
+}
+
 VkResult
-nvk_compile_nir(struct nvk_physical_device *pdev, nir_shader *nir,
+nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
-                const struct nak_fs_key *fs_key,
-                struct nvk_shader *shader)
+                const struct nvk_fs_key *fs_key,
+                struct nvk_shader **shader_out)
 {
-   if (use_nak(pdev, nir->info.stage)) {
-      return nvk_compile_nir_with_nak(pdev, nir, pipeline_flags, rs,
-                                      fs_key, shader);
-   } else {
-      return nvk_cg_compile_nir(pdev, nir, fs_key, shader);
-   }
+   struct nvk_physical_device *pdev = nvk_device_physical(dev);
+
+   struct nvk_shader *shader = nvk_shader_init(dev);
+   if (shader == NULL)
+      return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   if (use_nak(pdev, nir->info.stage))
+      VkResult result = nvk_compile_nir_with_nak(pdev, nir, pipeline_flags,
+                                                 rs, fs_key, shader);
+   else
+      VkResult result = nvk_cg_compile_nir(pdev, nir, fs_key, shader);
+
+   *shader_out = shader;
+   return result;
 }
 
 VkResult
@@ -504,6 +525,9 @@ nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader)
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
 {
+   if (shader == NULL)
+      return;
+
    if (shader->upload_size > 0) {
       nvk_heap_free(dev, &dev->shader_heap,
                     shader->upload_addr,
@@ -512,6 +536,8 @@ nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
 
    if (shader->nak)
       nak_shader_bin_destroy(shader->nak);
+
+   vk_free(&dev->vk.alloc, shader);
 }
 
 void
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index 556d8104852..04912606499 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -118,11 +118,11 @@ nvk_lower_nir(struct nvk_device *dev, nir_shader *nir,
               struct nvk_shader *shader);
 
 VkResult
-nvk_compile_nir(struct nvk_physical_device *dev, nir_shader *nir,
+nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
-                const struct nak_fs_key *fs_key,
-                struct nvk_shader *shader);
+                const struct nvk_fs_key *fs_key,
+                struct nvk_shader **shader_out);
 
 VkResult
 nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
-- 
2.43.0


From 5f5b9e30a7d6fba5d442640f71a5e0a16403c861 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 18 Oct 2023 23:55:36 +0200
Subject: [PATCH 04/10] nvk: pipeline shader cache

dEQP-VK.pipeline.monolithic.cache.*

Test run totals:
  Passed:        773/773 (100.0%)
  Failed:        0/773 (0.0%)
  Not supported: 0/773 (0.0%)
  Warnings:      0/773 (0.0%)
  Waived:        0/773 (0.0%)

Timing these test:
Before:
real    0m19,523s
user    0m15,858s
sys     0m0,654s

After:
real    0m6,521s
user    0m3,327s
sys     0m0,665s
---
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  49 ++++++--
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  72 ++++++++---
 src/nouveau/vulkan/nvk_pipeline.c          |   3 -
 src/nouveau/vulkan/nvk_shader.c            | 137 ++++++++++++++++++++-
 src/nouveau/vulkan/nvk_shader.h            |  11 ++
 5 files changed, 237 insertions(+), 35 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index eb3413d2eb5..ee2da38dd38 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -178,22 +178,47 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
                                      pCreateInfo->pNext,
                                      pCreateInfo->stage.pNext);
 
-   nir_shader *nir;
-   result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
-                                    cache, NULL, &nir);
-   if (result != VK_SUCCESS)
-      goto fail;
+   unsigned char sha1[SHA1_DIGEST_LENGTH];
+   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness,
+                   pipeline_layout, NULL);
 
-   struct nvk_shader *shader = pipeline->base.shaders[MESA_SHADER_COMPUTE];
+   bool cache_hit = false;
+   struct vk_pipeline_cache_object *object = NULL;
 
-   nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
+   if (cache) {
+      object = vk_pipeline_cache_lookup_object(cache, &sha1, sizeof(sha1),
+                                               &nvk_shader_ops, &cache_hit);
+      pipeline->base.shaders[MESA_SHADER_COMPUTE] =
+         container_of(object, struct nvk_shader, base);
+      result = VK_SUCCESS;
+   }
 
-   unsigned char sha1[SHA1_DIGEST_LENGTH];
-   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
+   if (!object) {
+      nir_shader *nir;
+      result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
+                                       cache, NULL, &nir);
+      if (result != VK_SUCCESS)
+         goto fail;
+
+      nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout);
+
+      struct nvk_shader *shader;
+      result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
+                               cache, sha1, &shader);
+
+      if (result == VK_SUCCESS) {
+         object = &shader->base;
+
+         if (cache)
+            object = vk_pipeline_cache_add_object(cache, object);
+
+         pipeline->base.shaders[MESA_SHADER_COMPUTE] =
+            container_of(object, struct nvk_shader, base);
+      }
+
+      ralloc_free(nir);
+   }
 
-   result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
-                            shader);
-   ralloc_free(nir);
    if (result != VK_SUCCESS)
       goto fail;
 
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 29c442ee930..ecae48434c2 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -186,6 +186,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
 
+   struct vk_pipeline_cache_object *objects[MESA_SHADER_STAGES] = {};
+
+   struct nvk_fs_key fs_key_tmp, *fs_key = NULL;
+   nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
+   fs_key = &fs_key_tmp;
+
    for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
       const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
       gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
@@ -199,6 +205,30 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
       vk_pipeline_robustness_state_fill(&dev->vk, &robustness[stage],
                                         pCreateInfo->pNext, sinfo->pNext);
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
+
+      unsigned char sha1[SHA1_DIGEST_LENGTH];
+      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
+                      stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
+
+      if (cache) {
+         bool cache_hit = false;
+         objects[stage] = vk_pipeline_cache_lookup_object(cache, &sha1, sizeof(sha1),
+                                                  &nvk_shader_ops, &cache_hit);
+         pipeline->base.shaders[stage] =
+            container_of(objects[stage], struct nvk_shader, base);
+      }
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL || objects[stage])
+         continue;
 
       result = nvk_shader_stage_to_nir(dev, sinfo, &robustness[stage],
                                        cache, NULL, &nir[stage]);
@@ -216,29 +246,33 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       if (sinfo == NULL)
          continue;
 
-      nvk_lower_nir(dev, nir[stage], &robustness[stage],
-                    state.rp->view_mask != 0, pipeline_layout,
-                    &pipeline->base.shaders[stage]);
-   }
+      if (!objects[stage]) {
+         nvk_lower_nir(dev, nir[stage], &robustness[stage],
+                       state.rp->view_mask != 0, pipeline_layout);
 
-   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
-      if (sinfo == NULL)
-         continue;
+         unsigned char sha1[SHA1_DIGEST_LENGTH];
+         nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
+                         stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
 
-      struct nak_fs_key fs_key_tmp, *fs_key = NULL;
-      if (stage == MESA_SHADER_FRAGMENT) {
-         nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
-         fs_key = &fs_key_tmp;
-      }
+         struct nvk_shader *shader;
+         result = nvk_compile_nir(dev, nir[stage], pipeline_flags, &robustness[stage],
+                                  stage == MESA_SHADER_FRAGMENT ? fs_key : NULL,
+                                  cache, sha1, &shader);
 
-      unsigned char sha1[SHA1_DIGEST_LENGTH];
-      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
+         if (result == VK_SUCCESS) {
+            objects[stage] = &shader->base;
+
+            if (cache)
+               objects[stage] = vk_pipeline_cache_add_object(cache,
+                                                             objects[stage]);
+
+            pipeline->base.shaders[stage] =
+               container_of(objects[stage], struct nvk_shader, base);
+         }
+
+         ralloc_free(nir[stage]);
+      }
 
-      result = nvk_compile_nir(dev, nir[stage], pipeline_flags,
-                               &robustness[stage], fs_key,
-                               &pipeline->base.shaders[stage]);
-      ralloc_free(nir[stage]);
       if (result != VK_SUCCESS)
          goto fail;
 
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index 29519e6c281..7c9d109e965 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -32,9 +32,6 @@ nvk_pipeline_free(struct nvk_device *dev,
                   struct nvk_pipeline *pipeline,
                   const VkAllocationCallbacks *pAllocator)
 {
-   for (uint32_t s = 0; s < ARRAY_SIZE(pipeline->shaders); s++)
-      nvk_shader_finish(dev, pipeline->shaders[s]);
-
    vk_object_free(&dev->vk, pAllocator, pipeline);
 }
 
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index 25047f5fb98..ba1a838bcb2 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -438,15 +438,21 @@ nvk_compile_nir_with_nak(struct nvk_physical_device *pdev,
 }
 
 static struct nvk_shader *
-nvk_shader_init(struct nvk_device *dev)
+nvk_shader_init(struct nvk_device *dev, const void *key_data, size_t key_size)
 {
    VK_MULTIALLOC(ma);
    VK_MULTIALLOC_DECL(&ma, struct nvk_shader, shader, 1);
+   VK_MULTIALLOC_DECL_SIZE(&ma, char, obj_key_data, key_size);
 
    if (!vk_multialloc_zalloc(&ma, &dev->vk.alloc,
                              VK_SYSTEM_ALLOCATION_SCOPE_DEVICE))
       return NULL;
 
+   memcpy(obj_key_data, key_data, key_size);
+
+   vk_pipeline_cache_object_init(&dev->vk, &shader->base,
+                                 &nvk_shader_ops, obj_key_data, key_size);
+
    return shader;
 }
 
@@ -455,12 +461,26 @@ nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
                 const struct nvk_fs_key *fs_key,
+                struct vk_pipeline_cache *cache,
+                unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out)
 {
    struct nvk_physical_device *pdev = nvk_device_physical(dev);
 
+<<<<<<< HEAD
    struct nvk_shader *shader = nvk_shader_init(dev);
    if (shader == NULL)
+=======
+   if (use_nak(pdev, nir->info.stage))
+      return nvk_compile_nir_with_nak(pdev, nir, fs_key, shader);
+
+   info = CALLOC_STRUCT(nv50_ir_prog_info);
+   if (!info)
+      return false;
+
+   struct nvk_shader *shader = nvk_shader_init(dev, hash, SHA1_DIGEST_LENGTH);
+   if(shader == NULL)
+>>>>>>> cda60b14147 (nvk: pipeline shader cache)
       return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    if (use_nak(pdev, nir->info.stage))
@@ -572,3 +592,118 @@ nvk_hash_shader(unsigned char *hash,
 
    _mesa_sha1_final(&ctx, hash);
 }
+
+static bool
+nvk_shader_serialize(struct vk_pipeline_cache_object *object,
+                     struct blob *blob);
+
+static struct vk_pipeline_cache_object *
+nvk_shader_deserialize(struct vk_pipeline_cache *cache,
+                       const void *key_data,
+                       size_t key_size,
+                       struct blob_reader *blob);
+
+void
+nvk_shader_destroy(struct vk_device *_dev,
+                   struct vk_pipeline_cache_object *object)
+{
+   struct nvk_device *dev =
+      container_of(_dev, struct nvk_device, vk);
+   struct nvk_shader *shader =
+      container_of(object, struct nvk_shader, base);
+
+   nvk_shader_finish(dev, shader);
+}
+
+const struct vk_pipeline_cache_object_ops nvk_shader_ops = {
+   .serialize = nvk_shader_serialize,
+   .deserialize = nvk_shader_deserialize,
+   .destroy = nvk_shader_destroy,
+};
+
+static bool
+nvk_shader_serialize(struct vk_pipeline_cache_object *object,
+                     struct blob *blob)
+{
+   struct nvk_shader *shader =
+      container_of(object, struct nvk_shader, base);
+
+   blob_write_bytes(blob, &shader->stage, sizeof(shader->stage));
+   blob_write_uint32(blob, shader->code_size);
+   blob_write_uint8(blob, shader->num_gprs);
+   blob_write_uint8(blob, shader->num_barriers);
+   blob_write_uint32(blob, shader->slm_size);
+   blob_write_bytes(blob, &shader->hdr, sizeof(shader->hdr));
+   blob_write_bytes(blob, &shader->flags, sizeof(shader->flags));
+
+   blob_write_bytes(blob, &shader->vs, sizeof(shader->vs));
+   blob_write_bytes(blob, &shader->fs, sizeof(shader->fs));
+   blob_write_bytes(blob, &shader->tp, sizeof(shader->tp));
+   blob_write_bytes(blob, &shader->cp, sizeof(shader->cp));
+
+   if (shader->xfb) {
+      blob_write_uint8(blob, 1);
+      blob_write_bytes(blob, shader->xfb, sizeof(*shader->xfb));
+   } else {
+      blob_write_uint8(blob, 0);
+   }
+
+   blob_write_bytes(blob, shader->code_ptr, shader->code_size);
+
+   return true;
+}
+
+static struct vk_pipeline_cache_object *
+nvk_shader_deserialize(struct vk_pipeline_cache *cache,
+                       const void *key_data,
+                       size_t key_size,
+                       struct blob_reader *blob)
+{
+   struct nvk_device *dev =
+      container_of(cache->base.device, struct nvk_device, vk);
+   struct nvk_shader *shader =
+      nvk_shader_init(dev, key_data, key_size);
+   struct nvk_transform_feedback_state *xfb = NULL;
+   uint8_t *code_ptr = NULL;
+
+   if (!shader)
+      return NULL;
+
+   blob_copy_bytes(blob, &shader->stage, sizeof(shader->stage));
+   shader->code_size = blob_read_uint32(blob);
+   shader->num_gprs = blob_read_uint8(blob);
+   shader->num_barriers = blob_read_uint8(blob);
+   shader->slm_size = blob_read_uint32(blob);
+
+   blob_copy_bytes(blob, &shader->hdr, sizeof(shader->hdr));
+   blob_copy_bytes(blob, &shader->flags, sizeof(shader->flags));
+
+   blob_copy_bytes(blob, &shader->vs, sizeof(shader->vs));
+   blob_copy_bytes(blob, &shader->fs, sizeof(shader->fs));
+   blob_copy_bytes(blob, &shader->tp, sizeof(shader->tp));
+   blob_copy_bytes(blob, &shader->cp, sizeof(shader->cp));
+
+   bool has_xfb = blob_read_uint8(blob);
+   if (has_xfb) {
+      xfb = malloc(sizeof(struct nvk_transform_feedback_state));
+      if(!xfb)
+         goto fail;
+
+      shader->xfb = xfb;
+      blob_copy_bytes(blob, shader->xfb, sizeof(*shader->xfb));
+   }
+
+   code_ptr = malloc(shader->code_size);
+   if (!code_ptr)
+      goto fail;
+
+   blob_copy_bytes(blob, code_ptr, shader->code_size);
+   shader->code_ptr = code_ptr;
+
+   return &shader->base;
+
+fail:
+   /* nvk_shader_destroy frees both shader and shader->xfb */
+   nvk_shader_destroy(cache->base.device, &shader->base);
+   return NULL;
+}
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index 04912606499..1166cc1b2a6 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -8,6 +8,8 @@
 #include "nvk_private.h"
 #include "nvk_device_memory.h"
 
+#include "vk_pipeline_cache.h"
+
 #include "nak.h"
 #include "nir.h"
 #include "nouveau_bo.h"
@@ -48,6 +50,7 @@ struct nvk_cbuf_map {
 struct nvk_shader {
    struct nak_shader_info info;
    struct nvk_cbuf_map cbuf_map;
+   struct vk_pipeline_cache_object base;
 
    struct nak_shader_bin *nak;
    const void *code_ptr;
@@ -122,11 +125,15 @@ nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
                 const struct nvk_fs_key *fs_key,
+                struct vk_pipeline_cache *cache,
+                unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out);
 
 VkResult
 nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
 
+extern const struct vk_pipeline_cache_object_ops nvk_shader_ops;
+
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader);
 
@@ -137,4 +144,8 @@ nvk_hash_shader(unsigned char *hash,
                  const struct vk_pipeline_layout *layout,
                  const struct nvk_fs_key *fs_key);
 
+void
+nvk_shader_destroy(struct vk_device *dev,
+                   struct vk_pipeline_cache_object *object);
+
 #endif
-- 
2.43.0


From 3bdaf64de49cc229a745354686a46cdfe2499546 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Mon, 23 Oct 2023 21:29:18 +0200
Subject: [PATCH 05/10] nvk: VK_EXT_pipeline_creation_feedback

dEQP-VK.*creation_feedback*

Test run totals:
  Passed:        13/73 (17.8%)
  Failed:        0/73 (0.0%)
  Not supported: 60/73 (82.2%)
  Warnings:      0/73 (0.0%)
  Waived:        0/73 (0.0%)
---
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 35 ++++++++++++++++++++++
 src/nouveau/vulkan/nvk_physical_device.c   |  1 +
 2 files changed, 36 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index ecae48434c2..2fdadba3d44 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -182,6 +182,17 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                             NULL, 0, &all, NULL, 0, NULL);
    assert(result == VK_SUCCESS);
 
+   VkPipelineCreationFeedbackEXT pipeline_feedback = {
+      .flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
+   };
+   VkPipelineCreationFeedbackEXT stage_feedbacks[MESA_SHADER_STAGES] = { 0 };
+
+   int64_t pipeline_start = os_time_get_nano();
+
+   const VkPipelineCreationFeedbackCreateInfo *creation_feedback =
+         vk_find_struct_const(pCreateInfo->pNext,
+                              PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
+
    const VkPipelineShaderStageCreateInfo *infos[MESA_SHADER_STAGES] = {};
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
@@ -222,6 +233,10 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                                   &nvk_shader_ops, &cache_hit);
          pipeline->base.shaders[stage] =
             container_of(objects[stage], struct nvk_shader, base);
+
+         if (cache_hit && cache != dev->mem_cache)
+            pipeline_feedback.flags |=
+               VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
       }
    }
 
@@ -247,6 +262,8 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
          continue;
 
       if (!objects[stage]) {
+         int64_t stage_start = os_time_get_nano();
+
          nvk_lower_nir(dev, nir[stage], &robustness[stage],
                        state.rp->view_mask != 0, pipeline_layout);
 
@@ -266,10 +283,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                objects[stage] = vk_pipeline_cache_add_object(cache,
                                                              objects[stage]);
 
+            stage_feedbacks[stage].flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT;
             pipeline->base.shaders[stage] =
                container_of(objects[stage], struct nvk_shader, base);
          }
 
+         stage_feedbacks[stage].duration += os_time_get_nano() - stage_start;
          ralloc_free(nir[stage]);
       }
 
@@ -410,6 +429,22 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
    pipeline->dynamic.ms.sample_locations = &pipeline->_dynamic_sl;
    vk_dynamic_graphics_state_fill(&pipeline->dynamic, &state);
 
+   pipeline_feedback.duration = os_time_get_nano() - pipeline_start;
+   if (creation_feedback) {
+      *creation_feedback->pPipelineCreationFeedback = pipeline_feedback;
+
+      int fb_count = creation_feedback->pipelineStageCreationFeedbackCount;
+      if (pCreateInfo->stageCount == fb_count) {
+         for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
+            const VkPipelineShaderStageCreateInfo *sinfo =
+               &pCreateInfo->pStages[i];
+            gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+            creation_feedback->pPipelineStageCreationFeedbacks[i] =
+               stage_feedbacks[stage];
+         }
+      }
+   }
+
    *pPipeline = nvk_pipeline_to_handle(&pipeline->base);
 
    return VK_SUCCESS;
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 8e9bab843a0..1543598f38a 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -164,6 +164,7 @@ nvk_get_device_extensions(const struct nv_device_info *info,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
       .EXT_pci_bus_info = info->type == NV_DEVICE_TYPE_DIS,
+      .EXT_pipeline_creation_feedback = true,
       .EXT_physical_device_drm = true,
       .EXT_primitive_topology_list_restart = true,
       .EXT_private_data = true,
-- 
2.43.0


From 0a84a6fe5fa3dc6eb9cad81179c702ff773bf0e9 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Fri, 6 Oct 2023 20:15:21 +0200
Subject: [PATCH 06/10] nvk: VK_EXT_pipeline_creation_cache_control

dEQP-VK.pipeline.monolithic.creation_cache_control.*

Test run totals:
  Passed:        16/18 (88.9%)
  Failed:        0/18 (0.0%)
  Not supported: 2/18 (11.1%)
  Warnings:      0/18 (0.0%)
  Waived:        0/18 (0.0%)
---
 src/nouveau/vulkan/nvk_compute_pipeline.c  | 6 ++++++
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 6 ++++++
 src/nouveau/vulkan/nvk_physical_device.c   | 2 ++
 3 files changed, 14 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index ee2da38dd38..3cb93b26dea 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -194,6 +194,12 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
    }
 
    if (!object) {
+      if (pCreateInfo->flags &
+          VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
+         result = VK_PIPELINE_COMPILE_REQUIRED;
+         goto fail;
+      }
+
       nir_shader *nir;
       result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
                                        cache, NULL, &nir);
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 2fdadba3d44..b37288b2e1c 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -238,6 +238,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
             pipeline_feedback.flags |=
                VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
       }
+
+      if (!objects[stage] && pCreateInfo->flags &
+         VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
+         result = VK_PIPELINE_COMPILE_REQUIRED;
+         goto fail;
+      }
    }
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 1543598f38a..b5ba65be31d 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -164,6 +164,7 @@ nvk_get_device_extensions(const struct nv_device_info *info,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
       .EXT_pci_bus_info = info->type == NV_DEVICE_TYPE_DIS,
+      .EXT_pipeline_creation_cache_control = true,
       .EXT_pipeline_creation_feedback = true,
       .EXT_physical_device_drm = true,
       .EXT_primitive_topology_list_restart = true,
@@ -314,6 +315,7 @@ nvk_get_device_features(const struct nv_device_info *info,
       .robustImageAccess = true,
       .inlineUniformBlock = true,
       .descriptorBindingInlineUniformBlockUpdateAfterBind = true,
+      .pipelineCreationCacheControl = true,
       .privateData = true,
       .shaderDemoteToHelperInvocation = true,
       .shaderTerminateInvocation = true,
-- 
2.43.0


From 0eb841e082babf7580434e61e1eb579200f7e461 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Mon, 23 Oct 2023 23:03:52 +0200
Subject: [PATCH 07/10] nvk: VK_EXT_shader_module_identifier

dEQP-VK.pipeline.monolithic.shader_module_identifier.*

Test run totals:
  Passed:        482/1292 (37.3%)
  Failed:        0/1292 (0.0%)
  Not supported: 810/1292 (62.7%)
  Warnings:      0/1292 (0.0%)
  Waived:        0/1292 (0.0%)
---
 src/nouveau/vulkan/nvk_physical_device.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index b5ba65be31d..d83111ed02a 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -18,6 +18,7 @@
 
 #include "vulkan/runtime/vk_device.h"
 #include "vulkan/runtime/vk_drm_syncobj.h"
+#include "vulkan/runtime/vk_shader_module.h"
 #include "vulkan/wsi/wsi_common.h"
 
 #include <sys/stat.h>
@@ -179,6 +180,7 @@ nvk_get_device_extensions(const struct nv_device_info *info,
       .EXT_shader_image_atomic_int64 = info->cls_eng3d >= MAXWELL_A &&
                                        nvk_use_nak(info),
       .EXT_shader_demote_to_helper_invocation = true,
+      .EXT_shader_module_identifier = true,
       .EXT_shader_subgroup_ballot = true,
       .EXT_shader_subgroup_vote = true,
       .EXT_shader_viewport_index_layer = info->cls_eng3d >= MAXWELL_B,
@@ -475,6 +477,9 @@ nvk_get_device_features(const struct nv_device_info *info,
       .sparseImageInt64Atomics = info->cls_eng3d >= MAXWELL_A &&
                                  nvk_use_nak(info),
 
+      /* VK_EXT_shader_module_identifier */
+      .shaderModuleIdentifier = true,
+
       /* VK_EXT_texel_buffer_alignment */
       .texelBufferAlignment = true,
 
@@ -798,6 +803,13 @@ nvk_get_device_properties(const struct nvk_instance *instance,
    snprintf(properties->deviceName, sizeof(properties->deviceName),
             "%s", info->device_name);
 
+   /* VK_EXT_shader_module_identifier */
+   STATIC_ASSERT(sizeof(vk_shaderModuleIdentifierAlgorithmUUID) ==
+      sizeof(properties->shaderModuleIdentifierAlgorithmUUID));
+   memcpy(properties->shaderModuleIdentifierAlgorithmUUID,
+            vk_shaderModuleIdentifierAlgorithmUUID,
+            sizeof(properties->shaderModuleIdentifierAlgorithmUUID));
+
    const struct {
       uint16_t vendor_id;
       uint16_t device_id;
-- 
2.43.0


From 35f2879bf2e2b0124543f053f95177ee31b520cc Mon Sep 17 00:00:00 2001
From: "Echo J." <aidas957@gmail.com>
Date: Wed, 15 Nov 2023 10:33:08 +0200
Subject: [PATCH 08/10] nvk: Various pipeline caching patch hotfixes

---
 src/nouveau/vulkan/nvk_cmd_buffer.c        |  4 +-
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  2 +-
 src/nouveau/vulkan/nvk_pipeline.c          |  6 +-
 src/nouveau/vulkan/nvk_shader.c            | 86 +++++++---------------
 src/nouveau/vulkan/nvk_shader.h            | 22 +++++-
 5 files changed, 53 insertions(+), 67 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_cmd_buffer.c b/src/nouveau/vulkan/nvk_cmd_buffer.c
index e763295df64..698c4ab23ad 100644
--- a/src/nouveau/vulkan/nvk_cmd_buffer.c
+++ b/src/nouveau/vulkan/nvk_cmd_buffer.c
@@ -539,8 +539,8 @@ nvk_CmdBindPipeline(VkCommandBuffer commandBuffer,
    for (unsigned s = 0; s < ARRAY_SIZE(pipeline->shaders); s++) {
       if (!pipeline->shaders[s])
          continue;
-      if (pipeline->shaders[s].info.slm_size)
-         nvk_device_ensure_slm(dev, pipeline->shaders[s].info.slm_size);
+      if (pipeline->shaders[s]->info.slm_size)
+         nvk_device_ensure_slm(dev, pipeline->shaders[s]->info.slm_size);
    }
 
    switch (pipelineBindPoint) {
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index b37288b2e1c..3b41818ef82 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -199,7 +199,7 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
    struct vk_pipeline_cache_object *objects[MESA_SHADER_STAGES] = {};
 
-   struct nvk_fs_key fs_key_tmp, *fs_key = NULL;
+   struct nak_fs_key fs_key_tmp, *fs_key = NULL;
    nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
    fs_key = &fs_key_tmp;
 
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index 7c9d109e965..8a4f68574a7 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -128,7 +128,7 @@ nvk_GetPipelineExecutablePropertiesKHR(
                           pProperties, pExecutableCount);
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (pipeline->shaders[stage].code_size == 0)
+      if (pipeline->shaders[stage]->code_size == 0)
          continue;
 
       vk_outarray_append_typed(VkPipelineExecutablePropertiesKHR, &out, props) {
@@ -147,11 +147,11 @@ static struct nvk_shader *
 shader_for_exe_idx(struct nvk_pipeline *pipeline, uint32_t idx)
 {
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (pipeline->shaders[stage].code_size == 0)
+      if (pipeline->shaders[stage]->code_size == 0)
          continue;
 
       if (idx == 0)
-         return &pipeline->shaders[stage];
+         return pipeline->shaders[stage];
 
       idx--;
    }
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index ba1a838bcb2..dfa89e001f3 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -460,34 +460,23 @@ VkResult
 nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
-                const struct nvk_fs_key *fs_key,
+                const struct nak_fs_key *fs_key,
                 struct vk_pipeline_cache *cache,
                 unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out)
 {
    struct nvk_physical_device *pdev = nvk_device_physical(dev);
-
-<<<<<<< HEAD
-   struct nvk_shader *shader = nvk_shader_init(dev);
-   if (shader == NULL)
-=======
-   if (use_nak(pdev, nir->info.stage))
-      return nvk_compile_nir_with_nak(pdev, nir, fs_key, shader);
-
-   info = CALLOC_STRUCT(nv50_ir_prog_info);
-   if (!info)
-      return false;
+   VkResult result = VK_SUCCESS;
 
    struct nvk_shader *shader = nvk_shader_init(dev, hash, SHA1_DIGEST_LENGTH);
-   if(shader == NULL)
->>>>>>> cda60b14147 (nvk: pipeline shader cache)
+   if (shader == NULL)
       return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    if (use_nak(pdev, nir->info.stage))
-      VkResult result = nvk_compile_nir_with_nak(pdev, nir, pipeline_flags,
-                                                 rs, fs_key, shader);
+      result = nvk_compile_nir_with_nak(pdev, nir, pipeline_flags,
+                                        rs, fs_key, shader);
    else
-      VkResult result = nvk_cg_compile_nir(pdev, nir, fs_key, shader);
+      result = nvk_cg_compile_nir(pdev, nir, fs_key, shader);
 
    *shader_out = shader;
    return result;
@@ -565,7 +554,7 @@ nvk_hash_shader(unsigned char *hash,
                 const VkPipelineShaderStageCreateInfo *sinfo,
                 const struct vk_pipeline_robustness_state *rstate,
                 const struct vk_pipeline_layout *layout,
-                const struct nvk_fs_key *fs_key)
+                const struct nak_fs_key *fs_key)
 {
    struct mesa_sha1 ctx;
 
@@ -628,25 +617,17 @@ nvk_shader_serialize(struct vk_pipeline_cache_object *object,
    struct nvk_shader *shader =
       container_of(object, struct nvk_shader, base);
 
-   blob_write_bytes(blob, &shader->stage, sizeof(shader->stage));
+   blob_write_bytes(blob, &shader->info.stage, sizeof(shader->info.stage));
    blob_write_uint32(blob, shader->code_size);
-   blob_write_uint8(blob, shader->num_gprs);
-   blob_write_uint8(blob, shader->num_barriers);
-   blob_write_uint32(blob, shader->slm_size);
-   blob_write_bytes(blob, &shader->hdr, sizeof(shader->hdr));
-   blob_write_bytes(blob, &shader->flags, sizeof(shader->flags));
-
-   blob_write_bytes(blob, &shader->vs, sizeof(shader->vs));
-   blob_write_bytes(blob, &shader->fs, sizeof(shader->fs));
-   blob_write_bytes(blob, &shader->tp, sizeof(shader->tp));
-   blob_write_bytes(blob, &shader->cp, sizeof(shader->cp));
-
-   if (shader->xfb) {
-      blob_write_uint8(blob, 1);
-      blob_write_bytes(blob, shader->xfb, sizeof(*shader->xfb));
-   } else {
-      blob_write_uint8(blob, 0);
-   }
+   blob_write_uint8(blob, shader->info.num_gprs);
+   blob_write_uint8(blob, shader->info.num_barriers);
+   blob_write_uint32(blob, shader->info.slm_size);
+
+   blob_write_bytes(blob, &shader->info.hdr, sizeof(shader->info.hdr));
+   blob_write_bytes(blob, &shader->info.cs, sizeof(shader->info.cs));
+   blob_write_bytes(blob, &shader->info.fs, sizeof(shader->info.fs));
+   blob_write_bytes(blob, &shader->info.ts, sizeof(shader->info.ts));
+   blob_write_bytes(blob, &shader->info.vtg, sizeof(shader->info.vtg));
 
    blob_write_bytes(blob, shader->code_ptr, shader->code_size);
 
@@ -663,35 +644,22 @@ nvk_shader_deserialize(struct vk_pipeline_cache *cache,
       container_of(cache->base.device, struct nvk_device, vk);
    struct nvk_shader *shader =
       nvk_shader_init(dev, key_data, key_size);
-   struct nvk_transform_feedback_state *xfb = NULL;
    uint8_t *code_ptr = NULL;
 
    if (!shader)
       return NULL;
 
-   blob_copy_bytes(blob, &shader->stage, sizeof(shader->stage));
+   blob_copy_bytes(blob, &shader->info.stage, sizeof(shader->info.stage));
    shader->code_size = blob_read_uint32(blob);
-   shader->num_gprs = blob_read_uint8(blob);
-   shader->num_barriers = blob_read_uint8(blob);
-   shader->slm_size = blob_read_uint32(blob);
-
-   blob_copy_bytes(blob, &shader->hdr, sizeof(shader->hdr));
-   blob_copy_bytes(blob, &shader->flags, sizeof(shader->flags));
-
-   blob_copy_bytes(blob, &shader->vs, sizeof(shader->vs));
-   blob_copy_bytes(blob, &shader->fs, sizeof(shader->fs));
-   blob_copy_bytes(blob, &shader->tp, sizeof(shader->tp));
-   blob_copy_bytes(blob, &shader->cp, sizeof(shader->cp));
-
-   bool has_xfb = blob_read_uint8(blob);
-   if (has_xfb) {
-      xfb = malloc(sizeof(struct nvk_transform_feedback_state));
-      if(!xfb)
-         goto fail;
-
-      shader->xfb = xfb;
-      blob_copy_bytes(blob, shader->xfb, sizeof(*shader->xfb));
-   }
+   shader->info.num_gprs = blob_read_uint8(blob);
+   shader->info.num_barriers = blob_read_uint8(blob);
+   shader->info.slm_size = blob_read_uint32(blob);
+
+   blob_copy_bytes(blob, &shader->info.hdr, sizeof(shader->info.hdr));
+   blob_copy_bytes(blob, &shader->info.cs, sizeof(shader->info.cs));
+   blob_copy_bytes(blob, &shader->info.fs, sizeof(shader->info.fs));
+   blob_copy_bytes(blob, &shader->info.ts, sizeof(shader->info.ts));
+   blob_copy_bytes(blob, &shader->info.vtg, sizeof(shader->info.vtg));
 
    code_ptr = malloc(shader->code_size);
    if (!code_ptr)
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index 1166cc1b2a6..8cbd554649b 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -124,7 +124,7 @@ VkResult
 nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
-                const struct nvk_fs_key *fs_key,
+                const struct nak_fs_key *fs_key,
                 struct vk_pipeline_cache *cache,
                 unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out);
@@ -142,10 +142,28 @@ nvk_hash_shader(unsigned char *hash,
                  const VkPipelineShaderStageCreateInfo *sinfo,
                  const struct vk_pipeline_robustness_state *rstate,
                  const struct vk_pipeline_layout *layout,
-                 const struct nvk_fs_key *fs_key);
+                 const struct nak_fs_key *fs_key);
 
 void
 nvk_shader_destroy(struct vk_device *dev,
                    struct vk_pipeline_cache_object *object);
 
+/* Codegen wrappers.
+ *
+ * TODO: Delete these once NAK supports everything.
+ */
+uint64_t nvk_cg_get_prog_debug(void);
+uint64_t nvk_cg_get_prog_optimize(void);
+
+const nir_shader_compiler_options *
+nvk_cg_nir_options(const struct nvk_physical_device *pdev,
+                   gl_shader_stage stage);
+
+void nvk_cg_preprocess_nir(nir_shader *nir);
+void nvk_cg_optimize_nir(nir_shader *nir);
+
+VkResult nvk_cg_compile_nir(struct nvk_physical_device *pdev, nir_shader *nir,
+                            const struct nak_fs_key *fs_key,
+                            struct nvk_shader *shader);
+
 #endif
-- 
2.43.0


From 4615b06ad42a4e3e17bfdecd6e307a145ad4d5aa Mon Sep 17 00:00:00 2001
From: "Echo J." <aidas957@gmail.com>
Date: Fri, 15 Dec 2023 12:27:59 +0200
Subject: [PATCH 09/10] nvk: Various pipeline caching hotfixes 2

---
 src/nouveau/vulkan/nvk_cmd_dispatch.c      | 2 +-
 src/nouveau/vulkan/nvk_cmd_draw.c          | 4 ++--
 src/nouveau/vulkan/nvk_compute_pipeline.c  | 5 +++--
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 5 +++--
 4 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_cmd_dispatch.c b/src/nouveau/vulkan/nvk_cmd_dispatch.c
index 2ca1e9daca1..c43bf377360 100644
--- a/src/nouveau/vulkan/nvk_cmd_dispatch.c
+++ b/src/nouveau/vulkan/nvk_cmd_dispatch.c
@@ -211,7 +211,7 @@ nvk_flush_compute_state(struct nvk_cmd_buffer *cmd,
    }
 
    const struct nvk_shader *shader =
-      &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+      pipeline->base.shaders[MESA_SHADER_COMPUTE];
    for (uint32_t c = 0; c < shader->cbuf_map.cbuf_count; c++) {
       const struct nvk_cbuf *cbuf = &shader->cbuf_map.cbufs[c];
 
diff --git a/src/nouveau/vulkan/nvk_cmd_draw.c b/src/nouveau/vulkan/nvk_cmd_draw.c
index 22b2b760d2f..705c17cd04a 100644
--- a/src/nouveau/vulkan/nvk_cmd_draw.c
+++ b/src/nouveau/vulkan/nvk_cmd_draw.c
@@ -1883,7 +1883,7 @@ nvk_flush_descriptors(struct nvk_cmd_buffer *cmd)
 
    uint32_t root_cbuf_count = 0;
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      const struct nvk_shader *shader = &pipeline->base.shaders[stage];
+      const struct nvk_shader *shader = pipeline->base.shaders[stage];
       if (shader->code_size == 0)
          continue;
 
@@ -1953,7 +1953,7 @@ nvk_flush_descriptors(struct nvk_cmd_buffer *cmd)
    P_NV9097_SET_CONSTANT_BUFFER_SELECTOR_C(p, root_desc_addr);
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      const struct nvk_shader *shader = &pipeline->base.shaders[stage];
+      const struct nvk_shader *shader = pipeline->base.shaders[stage];
       if (shader->code_size == 0)
          continue;
 
diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index 3cb93b26dea..5ee52710c4d 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -193,6 +193,8 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
       result = VK_SUCCESS;
    }
 
+   struct nvk_shader *shader = pipeline->base.shaders[MESA_SHADER_COMPUTE];
+
    if (!object) {
       if (pCreateInfo->flags &
           VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
@@ -206,9 +208,8 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
       if (result != VK_SUCCESS)
          goto fail;
 
-      nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout);
+      nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout, shader);
 
-      struct nvk_shader *shader;
       result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
                                cache, sha1, &shader);
 
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 3b41818ef82..37ccc646791 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -269,15 +269,16 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
       if (!objects[stage]) {
          int64_t stage_start = os_time_get_nano();
+         struct nvk_shader *shader;
 
          nvk_lower_nir(dev, nir[stage], &robustness[stage],
-                       state.rp->view_mask != 0, pipeline_layout);
+                       state.rp->view_mask != 0, pipeline_layout,
+                       shader);
 
          unsigned char sha1[SHA1_DIGEST_LENGTH];
          nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
                          stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
 
-         struct nvk_shader *shader;
          result = nvk_compile_nir(dev, nir[stage], pipeline_flags, &robustness[stage],
                                   stage == MESA_SHADER_FRAGMENT ? fs_key : NULL,
                                   cache, sha1, &shader);
-- 
2.43.0


From 9c3bea177490f936b5fb5924a4ec6092403a2318 Mon Sep 17 00:00:00 2001
From: "Echo J." <aidas957@gmail.com>
Date: Sat, 16 Dec 2023 11:17:34 +0200
Subject: [PATCH 10/10] nvk: Fix more pipeline caching compile errors

---
 src/nouveau/vulkan/nvk_cmd_draw.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_cmd_draw.c b/src/nouveau/vulkan/nvk_cmd_draw.c
index 705c17cd04a..e54bf619f17 100644
--- a/src/nouveau/vulkan/nvk_cmd_draw.c
+++ b/src/nouveau/vulkan/nvk_cmd_draw.c
@@ -934,7 +934,7 @@ nvk_cmd_bind_graphics_pipeline(struct nvk_cmd_buffer *cmd,
     * tessellation parameters at flush_ts_state, as the domain origin can be
     * dynamic.
     */
-   if (nvk_shader_is_enabled(&pipeline->base.shaders[MESA_SHADER_TESS_EVAL])) {
+   if (nvk_shader_is_enabled(pipeline->base.shaders[MESA_SHADER_TESS_EVAL])) {
       BITSET_SET(cmd->vk.dynamic_graphics_state.dirty,
                  MESA_VK_DYNAMIC_TS_DOMAIN_ORIGIN);
    }
@@ -1017,7 +1017,7 @@ nvk_flush_ts_state(struct nvk_cmd_buffer *cmd)
    if (BITSET_TEST(dyn->dirty, MESA_VK_DYNAMIC_TS_DOMAIN_ORIGIN)) {
       const struct nvk_graphics_pipeline *pipeline= cmd->state.gfx.pipeline;
       const struct nvk_shader *shader =
-         &pipeline->base.shaders[MESA_SHADER_TESS_EVAL];
+         pipeline->base.shaders[MESA_SHADER_TESS_EVAL];
 
       if (nvk_shader_is_enabled(shader)) {
          enum nak_ts_prims prims = shader->info.ts.prims;
-- 
2.43.0

