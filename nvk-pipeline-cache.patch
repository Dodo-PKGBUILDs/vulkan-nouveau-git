From 8fd5100c19ba766c9c131bc339a061028b961fb1 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 4 Oct 2023 20:37:40 +0200
Subject: [PATCH 1/8] nvk: loop over stages in MESA order

we do this to make the VkPipelineShaderStageCreateInfo available
when we want to calculate the shader hash
---
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 809fa8444df..e5ab3a3121c 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -323,12 +323,20 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                             NULL, 0, &all, NULL, 0, NULL);
    assert(result == VK_SUCCESS);
 
+   const VkPipelineShaderStageCreateInfo *infos[MESA_SHADER_STAGES] = {};
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
 
    for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
       const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
       gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+      infos[stage] = sinfo;
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
 
       vk_pipeline_robustness_state_fill(&dev->vk, &robustness[stage],
                                         pCreateInfo->pNext, sinfo->pNext);
@@ -344,15 +352,18 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       merge_tess_info(&nir[MESA_SHADER_TESS_EVAL]->info, &nir[MESA_SHADER_TESS_CTRL]->info);
    }
 
-   for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
-      const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
-      gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
+
       nvk_lower_nir(dev, nir[stage], &robustness[stage],
                     state.rp->view_mask != 0, pipeline_layout);
    }
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (nir[stage] == NULL)
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
          continue;
 
       struct nak_fs_key fs_key_tmp, *fs_key = NULL;
-- 
2.43.0


From e1d9a7a4bc9d49d145676042f8fa4396aebaad17 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 4 Oct 2023 20:38:01 +0200
Subject: [PATCH 2/8] nvk: add hashing for shaders

---
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  3 ++
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  3 ++
 src/nouveau/vulkan/nvk_shader.c            | 33 ++++++++++++++++++++++
 src/nouveau/vulkan/nvk_shader.h            | 23 ++++-----------
 4 files changed, 45 insertions(+), 17 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index f5ebde5154f..0f254b46718 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -186,6 +186,9 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
 
    nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout);
 
+   unsigned char sha1[SHA1_DIGEST_LENGTH];
+   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
+
    result = nvk_compile_nir(pdev, nir, pipeline_flags, &robustness, NULL,
                             &pipeline->base.shaders[MESA_SHADER_COMPUTE]);
    ralloc_free(nir);
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index e5ab3a3121c..08c2f556522 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -372,6 +372,9 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
          fs_key = &fs_key_tmp;
       }
 
+      unsigned char sha1[SHA1_DIGEST_LENGTH];
+      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
+
       result = nvk_compile_nir(pdev, nir[stage], pipeline_flags,
                                &robustness[stage], fs_key,
                                &pipeline->base.shaders[stage]);
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index b798daa8a36..a3639e6bfce 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -512,3 +512,36 @@ nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
    if (shader->nak)
       nak_shader_bin_destroy(shader->nak);
 }
+
+void
+nvk_hash_shader(unsigned char *hash,
+                const VkPipelineShaderStageCreateInfo *sinfo,
+                const struct vk_pipeline_robustness_state *rstate,
+                const struct vk_pipeline_layout *layout,
+                const struct nvk_fs_key *fs_key)
+{
+   struct mesa_sha1 ctx;
+
+   _mesa_sha1_init(&ctx);
+
+   unsigned char stage_sha1[SHA1_DIGEST_LENGTH];
+   vk_pipeline_hash_shader_stage(sinfo, rstate, stage_sha1);
+
+   _mesa_sha1_update(&ctx, stage_sha1, sizeof(stage_sha1));
+
+   if (layout) {
+      _mesa_sha1_update(&ctx, &layout->create_flags,
+                        sizeof(layout->create_flags));
+      _mesa_sha1_update(&ctx, &layout->set_count, sizeof(layout->set_count));
+      for (int i = 0; i < layout->set_count; i++) {
+         struct nvk_descriptor_set_layout *set =
+            vk_to_nvk_descriptor_set_layout(layout->set_layouts[i]);
+         _mesa_sha1_update(&ctx, &set->sha1, sizeof(set->sha1));
+      }
+   }
+
+   if(fs_key)
+      _mesa_sha1_update(&ctx, fs_key, sizeof(*fs_key));
+
+   _mesa_sha1_final(&ctx, hash);
+}
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index 62e1879e161..e1455fda939 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -101,22 +101,11 @@ nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader);
 
-/* Codegen wrappers.
- *
- * TODO: Delete these once NAK supports everything.
- */
-uint64_t nvk_cg_get_prog_debug(void);
-uint64_t nvk_cg_get_prog_optimize(void);
-
-const nir_shader_compiler_options *
-nvk_cg_nir_options(const struct nvk_physical_device *pdev,
-                   gl_shader_stage stage);
-
-void nvk_cg_preprocess_nir(nir_shader *nir);
-void nvk_cg_optimize_nir(nir_shader *nir);
-
-VkResult nvk_cg_compile_nir(struct nvk_physical_device *pdev, nir_shader *nir,
-                            const struct nak_fs_key *fs_key,
-                            struct nvk_shader *shader);
+void
+nvk_hash_shader(unsigned char *hash,
+                 const VkPipelineShaderStageCreateInfo *sinfo,
+                 const struct vk_pipeline_robustness_state *rstate,
+                 const struct vk_pipeline_layout *layout,
+                 const struct nvk_fs_key *fs_key);
 
 #endif
-- 
2.43.0


From a498669966ee6effc3bc963cd921384b5f82ac11 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Tue, 17 Oct 2023 02:08:33 +0200
Subject: [PATCH 3/8] nvk: allocatable nvk_shaders

This will be needed later when the shader life cycle will be managed
by the pipeline cache
---
 src/nouveau/vulkan/nvk_cmd_buffer.c        |  2 +
 src/nouveau/vulkan/nvk_cmd_dispatch.c      |  2 +-
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  6 +--
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 15 +++++---
 src/nouveau/vulkan/nvk_pipeline.c          |  2 +-
 src/nouveau/vulkan/nvk_pipeline.h          |  2 +-
 src/nouveau/vulkan/nvk_shader.c            | 44 +++++++++++++++++-----
 src/nouveau/vulkan/nvk_shader.h            |  6 +--
 8 files changed, 55 insertions(+), 24 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_cmd_buffer.c b/src/nouveau/vulkan/nvk_cmd_buffer.c
index 20727a004c4..76a35bd52f1 100644
--- a/src/nouveau/vulkan/nvk_cmd_buffer.c
+++ b/src/nouveau/vulkan/nvk_cmd_buffer.c
@@ -540,6 +540,8 @@ nvk_CmdBindPipeline(VkCommandBuffer commandBuffer,
    struct nvk_device *dev = nvk_cmd_buffer_device(cmd);
 
    for (unsigned s = 0; s < ARRAY_SIZE(pipeline->shaders); s++) {
+      if (!pipeline->shaders[s])
+         continue;
       if (pipeline->shaders[s].info.slm_size)
          nvk_device_ensure_slm(dev, pipeline->shaders[s].info.slm_size);
    }
diff --git a/src/nouveau/vulkan/nvk_cmd_dispatch.c b/src/nouveau/vulkan/nvk_cmd_dispatch.c
index 9697c61babc..c98456aa756 100644
--- a/src/nouveau/vulkan/nvk_cmd_dispatch.c
+++ b/src/nouveau/vulkan/nvk_cmd_dispatch.c
@@ -148,7 +148,7 @@ nvk_compute_local_size(struct nvk_cmd_buffer *cmd)
 {
    const struct nvk_compute_pipeline *pipeline = cmd->state.cs.pipeline;
    const struct nvk_shader *shader =
-      &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+      pipeline->base.shaders[MESA_SHADER_COMPUTE];
 
    return shader->info.cs.local_size[0] *
           shader->info.cs.local_size[1] *
diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index 0f254b46718..50e911fc0b8 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -189,18 +189,18 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
    unsigned char sha1[SHA1_DIGEST_LENGTH];
    nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
 
-   result = nvk_compile_nir(pdev, nir, pipeline_flags, &robustness, NULL,
+   result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
                             &pipeline->base.shaders[MESA_SHADER_COMPUTE]);
    ralloc_free(nir);
    if (result != VK_SUCCESS)
       goto fail;
 
    result = nvk_shader_upload(dev,
-                              &pipeline->base.shaders[MESA_SHADER_COMPUTE]);
+                              pipeline->base.shaders[MESA_SHADER_COMPUTE]);
    if (result != VK_SUCCESS)
       goto fail;
 
-   struct nvk_shader *shader = &pipeline->base.shaders[MESA_SHADER_COMPUTE];
+   struct nvk_shader *shader = pipeline->base.shaders[MESA_SHADER_COMPUTE];
    if (pdev->info.cls_compute >= AMPERE_COMPUTE_A)
       nvc6c0_compute_setup_launch_desc_template(pipeline->qmd_template, shader);
    else if (pdev->info.cls_compute >= VOLTA_COMPUTE_A)
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 08c2f556522..5022403db68 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -305,7 +305,6 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                              VkPipeline *pPipeline)
 {
    VK_FROM_HANDLE(vk_pipeline_layout, pipeline_layout, pCreateInfo->layout);
-   struct nvk_physical_device *pdev = nvk_device_physical(dev);
    struct nvk_graphics_pipeline *pipeline;
    VkResult result = VK_SUCCESS;
 
@@ -375,14 +374,14 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       unsigned char sha1[SHA1_DIGEST_LENGTH];
       nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
 
-      result = nvk_compile_nir(pdev, nir[stage], pipeline_flags,
+      result = nvk_compile_nir(dev, nir[stage], pipeline_flags,
                                &robustness[stage], fs_key,
                                &pipeline->base.shaders[stage]);
       ralloc_free(nir[stage]);
       if (result != VK_SUCCESS)
          goto fail;
 
-      result = nvk_shader_upload(dev, &pipeline->base.shaders[stage]);
+      result = nvk_shader_upload(dev, pipeline->base.shaders[stage]);
       if (result != VK_SUCCESS)
          goto fail;
    }
@@ -395,15 +394,19 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
    struct nvk_shader *last_geom = NULL;
    for (gl_shader_stage stage = 0; stage <= MESA_SHADER_FRAGMENT; stage++) {
-      struct nvk_shader *shader = &pipeline->base.shaders[stage];
+      struct nvk_shader *shader = pipeline->base.shaders[stage];
+      uint32_t upload_size = 0;
+      if (shader)
+         upload_size = shader->upload_size;
+
       uint32_t idx = mesa_to_nv9097_shader_type[stage];
 
       P_IMMD(p, NV9097, SET_PIPELINE_SHADER(idx), {
-         .enable  = shader->upload_size > 0,
+         .enable  = upload_size > 0,
          .type    = mesa_to_nv9097_shader_type[stage],
       });
 
-      if (shader->upload_size == 0)
+      if (!shader || shader->upload_size == 0)
          continue;
 
       if (stage != MESA_SHADER_FRAGMENT)
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index a4ee7f8b37f..29519e6c281 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -33,7 +33,7 @@ nvk_pipeline_free(struct nvk_device *dev,
                   const VkAllocationCallbacks *pAllocator)
 {
    for (uint32_t s = 0; s < ARRAY_SIZE(pipeline->shaders); s++)
-      nvk_shader_finish(dev, &pipeline->shaders[s]);
+      nvk_shader_finish(dev, pipeline->shaders[s]);
 
    vk_object_free(&dev->vk, pAllocator, pipeline);
 }
diff --git a/src/nouveau/vulkan/nvk_pipeline.h b/src/nouveau/vulkan/nvk_pipeline.h
index c48bd92764b..b7a33249ddb 100644
--- a/src/nouveau/vulkan/nvk_pipeline.h
+++ b/src/nouveau/vulkan/nvk_pipeline.h
@@ -23,7 +23,7 @@ struct nvk_pipeline {
 
    enum nvk_pipeline_type type;
 
-   struct nvk_shader shaders[MESA_SHADER_STAGES];
+   struct nvk_shader *shaders[MESA_SHADER_STAGES];
 };
 
 VK_DEFINE_NONDISP_HANDLE_CASTS(nvk_pipeline, base, VkPipeline,
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index a3639e6bfce..0c55cf640f4 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -436,19 +436,40 @@ nvk_compile_nir_with_nak(struct nvk_physical_device *pdev,
    return VK_SUCCESS;
 }
 
+static struct nvk_shader *
+nvk_shader_init(struct nvk_device *dev)
+{
+   VK_MULTIALLOC(ma);
+   VK_MULTIALLOC_DECL(&ma, struct nvk_shader, shader, 1);
+
+   if (!vk_multialloc_zalloc(&ma, &dev->vk.alloc,
+                             VK_SYSTEM_ALLOCATION_SCOPE_DEVICE))
+      return NULL;
+
+   return shader;
+}
+
 VkResult
-nvk_compile_nir(struct nvk_physical_device *pdev, nir_shader *nir,
+nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
-                const struct nak_fs_key *fs_key,
-                struct nvk_shader *shader)
+                const struct nvk_fs_key *fs_key,
+                struct nvk_shader **shader_out)
 {
-   if (use_nak(pdev, nir->info.stage)) {
-      return nvk_compile_nir_with_nak(pdev, nir, pipeline_flags, rs,
-                                      fs_key, shader);
-   } else {
-      return nvk_cg_compile_nir(pdev, nir, fs_key, shader);
-   }
+   struct nvk_physical_device *pdev = nvk_device_physical(dev);
+
+   struct nvk_shader *shader = nvk_shader_init(dev);
+   if (shader == NULL)
+      return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   if (use_nak(pdev, nir->info.stage))
+      VkResult result = nvk_compile_nir_with_nak(pdev, nir, pipeline_flags,
+                                                 rs, fs_key, shader);
+   else
+      VkResult result = nvk_cg_compile_nir(pdev, nir, fs_key, shader);
+
+   *shader_out = shader;
+   return result;
 }
 
 VkResult
@@ -503,6 +524,9 @@ nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader)
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
 {
+   if (shader == NULL)
+      return;
+
    if (shader->upload_size > 0) {
       nvk_heap_free(dev, &dev->shader_heap,
                     shader->upload_addr,
@@ -511,6 +535,8 @@ nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader)
 
    if (shader->nak)
       nak_shader_bin_destroy(shader->nak);
+
+   vk_free(&dev->vk.alloc, shader);
 }
 
 void
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index e1455fda939..d9bda890a42 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -89,11 +89,11 @@ nvk_lower_nir(struct nvk_device *dev, nir_shader *nir,
               const struct vk_pipeline_layout *layout);
 
 VkResult
-nvk_compile_nir(struct nvk_physical_device *dev, nir_shader *nir,
+nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
-                const struct nak_fs_key *fs_key,
-                struct nvk_shader *shader);
+                const struct nvk_fs_key *fs_key,
+                struct nvk_shader **shader_out);
 
 VkResult
 nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
-- 
2.43.0


From 01b5c39c91fd1ff4d0a2f7a283d54d94ee3076ab Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Wed, 18 Oct 2023 23:55:36 +0200
Subject: [PATCH 4/8] nvk: pipeline shader cache

dEQP-VK.pipeline.monolithic.cache.*

Test run totals:
  Passed:        773/773 (100.0%)
  Failed:        0/773 (0.0%)
  Not supported: 0/773 (0.0%)
  Warnings:      0/773 (0.0%)
  Waived:        0/773 (0.0%)

Timing these test:
Before:
real    0m19,523s
user    0m15,858s
sys     0m0,654s

After:
real    0m6,521s
user    0m3,327s
sys     0m0,665s
---
 src/nouveau/vulkan/nvk_compute_pipeline.c  |  49 ++++++--
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  72 ++++++++---
 src/nouveau/vulkan/nvk_pipeline.c          |   3 -
 src/nouveau/vulkan/nvk_shader.c            | 137 ++++++++++++++++++++-
 src/nouveau/vulkan/nvk_shader.h            |  11 ++
 5 files changed, 239 insertions(+), 33 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index 50e911fc0b8..9f48cbc7358 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -178,20 +178,47 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
                                      pCreateInfo->pNext,
                                      pCreateInfo->stage.pNext);
 
-   nir_shader *nir;
-   result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
-                                    cache, NULL, &nir);
-   if (result != VK_SUCCESS)
-      goto fail;
+   unsigned char sha1[SHA1_DIGEST_LENGTH];
+   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness,
+                   pipeline_layout, NULL);
 
-   nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout);
+   bool cache_hit = false;
+   struct vk_pipeline_cache_object *object = NULL;
 
-   unsigned char sha1[SHA1_DIGEST_LENGTH];
-   nvk_hash_shader(sha1, &pCreateInfo->stage, &robustness, pipeline_layout, NULL);
+   if (cache) {
+      object = vk_pipeline_cache_lookup_object(cache, &sha1, sizeof(sha1),
+                                               &nvk_shader_ops, &cache_hit);
+      pipeline->base.shaders[MESA_SHADER_COMPUTE] =
+         container_of(object, struct nvk_shader, base);
+      result = VK_SUCCESS;
+   }
+
+   if (!object) {
+      nir_shader *nir;
+      result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
+                                       cache, NULL, &nir);
+      if (result != VK_SUCCESS)
+         goto fail;
+
+      nvk_lower_nir(dev, nir, &robustness, false, pipeline_layout);
+
+      struct nvk_shader *shader;
+      result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
+                               cache, sha1, &shader);
+
+      if (result == VK_SUCCESS) {
+         object = &shader->base;
+
+         if (cache)
+            object = vk_pipeline_cache_add_object(cache, object);
+
+         pipeline->base.shaders[MESA_SHADER_COMPUTE] =
+            container_of(object, struct nvk_shader, base);
+      }
+
+      ralloc_free(nir);
+   }
 
-   result = nvk_compile_nir(dev, nir, pipeline_flags, &robustness, NULL,
-                            &pipeline->base.shaders[MESA_SHADER_COMPUTE]);
-   ralloc_free(nir);
    if (result != VK_SUCCESS)
       goto fail;
 
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 5022403db68..13ca0773552 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -326,6 +326,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
 
+   struct vk_pipeline_cache_object *objects[MESA_SHADER_STAGES] = {};
+
+   struct nvk_fs_key fs_key_tmp, *fs_key = NULL;
+   nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
+   fs_key = &fs_key_tmp;
+
    for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
       const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
       gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
@@ -339,6 +345,30 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
       vk_pipeline_robustness_state_fill(&dev->vk, &robustness[stage],
                                         pCreateInfo->pNext, sinfo->pNext);
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL)
+         continue;
+
+      unsigned char sha1[SHA1_DIGEST_LENGTH];
+      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
+                      stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
+
+      if (cache) {
+         bool cache_hit = false;
+         objects[stage] = vk_pipeline_cache_lookup_object(cache, &sha1, sizeof(sha1),
+                                                  &nvk_shader_ops, &cache_hit);
+         pipeline->base.shaders[stage] =
+            container_of(objects[stage], struct nvk_shader, base);
+      }
+   }
+
+   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
+      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
+      if (sinfo == NULL || objects[stage])
+         continue;
 
       result = nvk_shader_stage_to_nir(dev, sinfo, &robustness[stage],
                                        cache, NULL, &nir[stage]);
@@ -356,28 +386,34 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
       if (sinfo == NULL)
          continue;
 
-      nvk_lower_nir(dev, nir[stage], &robustness[stage],
-                    state.rp->view_mask != 0, pipeline_layout);
-   }
+      if (!objects[stage]) {
 
-   for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      const VkPipelineShaderStageCreateInfo *sinfo = infos[stage];
-      if (sinfo == NULL)
-         continue;
+         nvk_lower_nir(dev, nir[stage], &robustness[stage],
+                       state.rp->view_mask != 0, pipeline_layout);
 
-      struct nak_fs_key fs_key_tmp, *fs_key = NULL;
-      if (stage == MESA_SHADER_FRAGMENT) {
-         nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
-         fs_key = &fs_key_tmp;
-      }
+         unsigned char sha1[SHA1_DIGEST_LENGTH];
+         nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout,
+                         stage == MESA_SHADER_FRAGMENT ? fs_key : NULL);
 
-      unsigned char sha1[SHA1_DIGEST_LENGTH];
-      nvk_hash_shader(sha1, sinfo, &robustness[stage], pipeline_layout, fs_key);
+         struct nvk_shader *shader;
+         result = nvk_compile_nir(dev, nir[stage], pipeline_flags, &robustness[stage],
+                                  stage == MESA_SHADER_FRAGMENT ? fs_key : NULL,
+                                  cache, sha1, &shader);
+
+         if (result == VK_SUCCESS) {
+            objects[stage] = &shader->base;
+
+            if (cache)
+               objects[stage] = vk_pipeline_cache_add_object(cache,
+                                                             objects[stage]);
+
+            pipeline->base.shaders[stage] =
+               container_of(objects[stage], struct nvk_shader, base);
+         }
+
+         ralloc_free(nir[stage]);
+      }
 
-      result = nvk_compile_nir(dev, nir[stage], pipeline_flags,
-                               &robustness[stage], fs_key,
-                               &pipeline->base.shaders[stage]);
-      ralloc_free(nir[stage]);
       if (result != VK_SUCCESS)
          goto fail;
 
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index 29519e6c281..7c9d109e965 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -32,9 +32,6 @@ nvk_pipeline_free(struct nvk_device *dev,
                   struct nvk_pipeline *pipeline,
                   const VkAllocationCallbacks *pAllocator)
 {
-   for (uint32_t s = 0; s < ARRAY_SIZE(pipeline->shaders); s++)
-      nvk_shader_finish(dev, pipeline->shaders[s]);
-
    vk_object_free(&dev->vk, pAllocator, pipeline);
 }
 
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index 0c55cf640f4..9de03b2bee5 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -437,15 +437,21 @@ nvk_compile_nir_with_nak(struct nvk_physical_device *pdev,
 }
 
 static struct nvk_shader *
-nvk_shader_init(struct nvk_device *dev)
+nvk_shader_init(struct nvk_device *dev, const void *key_data, size_t key_size)
 {
    VK_MULTIALLOC(ma);
    VK_MULTIALLOC_DECL(&ma, struct nvk_shader, shader, 1);
+   VK_MULTIALLOC_DECL_SIZE(&ma, char, obj_key_data, key_size);
 
    if (!vk_multialloc_zalloc(&ma, &dev->vk.alloc,
                              VK_SYSTEM_ALLOCATION_SCOPE_DEVICE))
       return NULL;
 
+   memcpy(obj_key_data, key_data, key_size);
+
+   vk_pipeline_cache_object_init(&dev->vk, &shader->base,
+                                 &nvk_shader_ops, obj_key_data, key_size);
+
    return shader;
 }
 
@@ -454,12 +460,26 @@ nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
                 const struct nvk_fs_key *fs_key,
+                struct vk_pipeline_cache *cache,
+                unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out)
 {
    struct nvk_physical_device *pdev = nvk_device_physical(dev);
 
+<<<<<<< HEAD
    struct nvk_shader *shader = nvk_shader_init(dev);
    if (shader == NULL)
+=======
+   if (use_nak(pdev, nir->info.stage))
+      return nvk_compile_nir_with_nak(pdev, nir, fs_key, shader);
+
+   info = CALLOC_STRUCT(nv50_ir_prog_info);
+   if (!info)
+      return false;
+
+   struct nvk_shader *shader = nvk_shader_init(dev, hash, SHA1_DIGEST_LENGTH);
+   if(shader == NULL)
+>>>>>>> cda60b14147 (nvk: pipeline shader cache)
       return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    if (use_nak(pdev, nir->info.stage))
@@ -571,3 +591,118 @@ nvk_hash_shader(unsigned char *hash,
 
    _mesa_sha1_final(&ctx, hash);
 }
+
+static bool
+nvk_shader_serialize(struct vk_pipeline_cache_object *object,
+                     struct blob *blob);
+
+static struct vk_pipeline_cache_object *
+nvk_shader_deserialize(struct vk_pipeline_cache *cache,
+                       const void *key_data,
+                       size_t key_size,
+                       struct blob_reader *blob);
+
+void
+nvk_shader_destroy(struct vk_device *_dev,
+                   struct vk_pipeline_cache_object *object)
+{
+   struct nvk_device *dev =
+      container_of(_dev, struct nvk_device, vk);
+   struct nvk_shader *shader =
+      container_of(object, struct nvk_shader, base);
+
+   nvk_shader_finish(dev, shader);
+}
+
+const struct vk_pipeline_cache_object_ops nvk_shader_ops = {
+   .serialize = nvk_shader_serialize,
+   .deserialize = nvk_shader_deserialize,
+   .destroy = nvk_shader_destroy,
+};
+
+static bool
+nvk_shader_serialize(struct vk_pipeline_cache_object *object,
+                     struct blob *blob)
+{
+   struct nvk_shader *shader =
+      container_of(object, struct nvk_shader, base);
+
+   blob_write_bytes(blob, &shader->stage, sizeof(shader->stage));
+   blob_write_uint32(blob, shader->code_size);
+   blob_write_uint8(blob, shader->num_gprs);
+   blob_write_uint8(blob, shader->num_barriers);
+   blob_write_uint32(blob, shader->slm_size);
+   blob_write_bytes(blob, &shader->hdr, sizeof(shader->hdr));
+   blob_write_bytes(blob, &shader->flags, sizeof(shader->flags));
+
+   blob_write_bytes(blob, &shader->vs, sizeof(shader->vs));
+   blob_write_bytes(blob, &shader->fs, sizeof(shader->fs));
+   blob_write_bytes(blob, &shader->tp, sizeof(shader->tp));
+   blob_write_bytes(blob, &shader->cp, sizeof(shader->cp));
+
+   if (shader->xfb) {
+      blob_write_uint8(blob, 1);
+      blob_write_bytes(blob, shader->xfb, sizeof(*shader->xfb));
+   } else {
+      blob_write_uint8(blob, 0);
+   }
+
+   blob_write_bytes(blob, shader->code_ptr, shader->code_size);
+
+   return true;
+}
+
+static struct vk_pipeline_cache_object *
+nvk_shader_deserialize(struct vk_pipeline_cache *cache,
+                       const void *key_data,
+                       size_t key_size,
+                       struct blob_reader *blob)
+{
+   struct nvk_device *dev =
+      container_of(cache->base.device, struct nvk_device, vk);
+   struct nvk_shader *shader =
+      nvk_shader_init(dev, key_data, key_size);
+   struct nvk_transform_feedback_state *xfb = NULL;
+   uint8_t *code_ptr = NULL;
+
+   if (!shader)
+      return NULL;
+
+   blob_copy_bytes(blob, &shader->stage, sizeof(shader->stage));
+   shader->code_size = blob_read_uint32(blob);
+   shader->num_gprs = blob_read_uint8(blob);
+   shader->num_barriers = blob_read_uint8(blob);
+   shader->slm_size = blob_read_uint32(blob);
+
+   blob_copy_bytes(blob, &shader->hdr, sizeof(shader->hdr));
+   blob_copy_bytes(blob, &shader->flags, sizeof(shader->flags));
+
+   blob_copy_bytes(blob, &shader->vs, sizeof(shader->vs));
+   blob_copy_bytes(blob, &shader->fs, sizeof(shader->fs));
+   blob_copy_bytes(blob, &shader->tp, sizeof(shader->tp));
+   blob_copy_bytes(blob, &shader->cp, sizeof(shader->cp));
+
+   bool has_xfb = blob_read_uint8(blob);
+   if (has_xfb) {
+      xfb = malloc(sizeof(struct nvk_transform_feedback_state));
+      if(!xfb)
+         goto fail;
+
+      shader->xfb = xfb;
+      blob_copy_bytes(blob, shader->xfb, sizeof(*shader->xfb));
+   }
+
+   code_ptr = malloc(shader->code_size);
+   if (!code_ptr)
+      goto fail;
+
+   blob_copy_bytes(blob, code_ptr, shader->code_size);
+   shader->code_ptr = code_ptr;
+
+   return &shader->base;
+
+fail:
+   /* nvk_shader_destroy frees both shader and shader->xfb */
+   nvk_shader_destroy(cache->base.device, &shader->base);
+   return NULL;
+}
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index d9bda890a42..fd57db2eb54 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -8,6 +8,8 @@
 #include "nvk_private.h"
 #include "nvk_device_memory.h"
 
+#include "vk_pipeline_cache.h"
+
 #include "nak.h"
 #include "nir.h"
 #include "nouveau_bo.h"
@@ -27,6 +29,7 @@ struct vk_shader_module;
 
 struct nvk_shader {
    struct nak_shader_info info;
+   struct vk_pipeline_cache_object base;
 
    struct nak_shader_bin *nak;
    const void *code_ptr;
@@ -93,11 +96,15 @@ nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
                 const struct nvk_fs_key *fs_key,
+                struct vk_pipeline_cache *cache,
+                unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out);
 
 VkResult
 nvk_shader_upload(struct nvk_device *dev, struct nvk_shader *shader);
 
+extern const struct vk_pipeline_cache_object_ops nvk_shader_ops;
+
 void
 nvk_shader_finish(struct nvk_device *dev, struct nvk_shader *shader);
 
@@ -108,4 +115,8 @@ nvk_hash_shader(unsigned char *hash,
                  const struct vk_pipeline_layout *layout,
                  const struct nvk_fs_key *fs_key);
 
+void
+nvk_shader_destroy(struct vk_device *dev,
+                   struct vk_pipeline_cache_object *object);
+
 #endif
-- 
2.43.0


From 988635e10b97546a3e284b7b50775d47e736030d Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Mon, 23 Oct 2023 21:29:18 +0200
Subject: [PATCH 5/8] nvk: VK_EXT_pipeline_creation_feedback

dEQP-VK.*creation_feedback*

Test run totals:
  Passed:        13/73 (17.8%)
  Failed:        0/73 (0.0%)
  Not supported: 60/73 (82.2%)
  Warnings:      0/73 (0.0%)
  Waived:        0/73 (0.0%)
---
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 34 ++++++++++++++++++++++
 src/nouveau/vulkan/nvk_physical_device.c   |  1 +
 2 files changed, 35 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 13ca0773552..a3fa6ad0926 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -322,6 +322,17 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                             NULL, 0, &all, NULL, 0, NULL);
    assert(result == VK_SUCCESS);
 
+   VkPipelineCreationFeedbackEXT pipeline_feedback = {
+      .flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
+   };
+   VkPipelineCreationFeedbackEXT stage_feedbacks[MESA_SHADER_STAGES] = { 0 };
+
+   int64_t pipeline_start = os_time_get_nano();
+
+   const VkPipelineCreationFeedbackCreateInfo *creation_feedback =
+         vk_find_struct_const(pCreateInfo->pNext,
+                              PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
+
    const VkPipelineShaderStageCreateInfo *infos[MESA_SHADER_STAGES] = {};
    nir_shader *nir[MESA_SHADER_STAGES] = {};
    struct vk_pipeline_robustness_state robustness[MESA_SHADER_STAGES];
@@ -362,6 +373,10 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                                                   &nvk_shader_ops, &cache_hit);
          pipeline->base.shaders[stage] =
             container_of(objects[stage], struct nvk_shader, base);
+
+         if (cache_hit && cache != dev->mem_cache)
+            pipeline_feedback.flags |=
+               VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
       }
    }
 
@@ -387,6 +402,7 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
          continue;
 
       if (!objects[stage]) {
+         int64_t stage_start = os_time_get_nano();
 
          nvk_lower_nir(dev, nir[stage], &robustness[stage],
                        state.rp->view_mask != 0, pipeline_layout);
@@ -407,10 +423,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
                objects[stage] = vk_pipeline_cache_add_object(cache,
                                                              objects[stage]);
 
+            stage_feedbacks[stage].flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT;
             pipeline->base.shaders[stage] =
                container_of(objects[stage], struct nvk_shader, base);
          }
 
+         stage_feedbacks[stage].duration += os_time_get_nano() - stage_start;
          ralloc_free(nir[stage]);
       }
 
@@ -559,6 +577,22 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
    pipeline->dynamic.ms.sample_locations = &pipeline->_dynamic_sl;
    vk_dynamic_graphics_state_fill(&pipeline->dynamic, &state);
 
+   pipeline_feedback.duration = os_time_get_nano() - pipeline_start;
+   if (creation_feedback) {
+      *creation_feedback->pPipelineCreationFeedback = pipeline_feedback;
+
+      int fb_count = creation_feedback->pipelineStageCreationFeedbackCount;
+      if (pCreateInfo->stageCount == fb_count) {
+         for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
+            const VkPipelineShaderStageCreateInfo *sinfo =
+               &pCreateInfo->pStages[i];
+            gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
+            creation_feedback->pPipelineStageCreationFeedbacks[i] =
+               stage_feedbacks[stage];
+         }
+      }
+   }
+
    *pPipeline = nvk_pipeline_to_handle(&pipeline->base);
 
    return VK_SUCCESS;
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index c407725c835..f3d60fd4f70 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -160,6 +160,7 @@ nvk_get_device_extensions(const struct nv_device_info *info,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
       .EXT_pci_bus_info = info->type == NV_DEVICE_TYPE_DIS,
+      .EXT_pipeline_creation_feedback = true,
       .EXT_physical_device_drm = true,
       .EXT_primitive_topology_list_restart = true,
       .EXT_private_data = true,
-- 
2.43.0


From 4eb68bd51233413f85de974fbabbb0ac3b42eed6 Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Fri, 6 Oct 2023 20:15:21 +0200
Subject: [PATCH 6/8] nvk: VK_EXT_pipeline_creation_cache_control

dEQP-VK.pipeline.monolithic.creation_cache_control.*

Test run totals:
  Passed:        16/18 (88.9%)
  Failed:        0/18 (0.0%)
  Not supported: 2/18 (11.1%)
  Warnings:      0/18 (0.0%)
  Waived:        0/18 (0.0%)
---
 src/nouveau/vulkan/nvk_compute_pipeline.c  | 6 ++++++
 src/nouveau/vulkan/nvk_graphics_pipeline.c | 6 ++++++
 src/nouveau/vulkan/nvk_physical_device.c   | 2 ++
 3 files changed, 14 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_compute_pipeline.c b/src/nouveau/vulkan/nvk_compute_pipeline.c
index 9f48cbc7358..08dc773c7b2 100644
--- a/src/nouveau/vulkan/nvk_compute_pipeline.c
+++ b/src/nouveau/vulkan/nvk_compute_pipeline.c
@@ -194,6 +194,12 @@ nvk_compute_pipeline_create(struct nvk_device *dev,
    }
 
    if (!object) {
+      if (pCreateInfo->flags &
+          VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
+         result = VK_PIPELINE_COMPILE_REQUIRED;
+         goto fail;
+      }
+
       nir_shader *nir;
       result = nvk_shader_stage_to_nir(dev, &pCreateInfo->stage, &robustness,
                                        cache, NULL, &nir);
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index a3fa6ad0926..83b0957d7d4 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -378,6 +378,12 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
             pipeline_feedback.flags |=
                VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
       }
+
+      if (!objects[stage] && pCreateInfo->flags &
+         VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
+         result = VK_PIPELINE_COMPILE_REQUIRED;
+         goto fail;
+      }
    }
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index f3d60fd4f70..85950e86006 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -160,6 +160,7 @@ nvk_get_device_extensions(const struct nv_device_info *info,
       .EXT_mutable_descriptor_type = true,
       .EXT_non_seamless_cube_map = true,
       .EXT_pci_bus_info = info->type == NV_DEVICE_TYPE_DIS,
+      .EXT_pipeline_creation_cache_control = true,
       .EXT_pipeline_creation_feedback = true,
       .EXT_physical_device_drm = true,
       .EXT_primitive_topology_list_restart = true,
@@ -307,6 +308,7 @@ nvk_get_device_features(const struct nv_device_info *info,
       .robustImageAccess = true,
       .inlineUniformBlock = true,
       .descriptorBindingInlineUniformBlockUpdateAfterBind = true,
+      .pipelineCreationCacheControl = true,
       .privateData = true,
       .shaderDemoteToHelperInvocation = true,
       .shaderTerminateInvocation = true,
-- 
2.43.0


From 764b218fa38e61ad026456460e7c820f5e6a80ed Mon Sep 17 00:00:00 2001
From: "Thomas H.P. Andersen" <phomes@gmail.com>
Date: Mon, 23 Oct 2023 23:03:52 +0200
Subject: [PATCH 7/8] nvk: VK_EXT_shader_module_identifier

dEQP-VK.pipeline.monolithic.shader_module_identifier.*

Test run totals:
  Passed:        482/1292 (37.3%)
  Failed:        0/1292 (0.0%)
  Not supported: 810/1292 (62.7%)
  Warnings:      0/1292 (0.0%)
  Waived:        0/1292 (0.0%)
---
 src/nouveau/vulkan/nvk_physical_device.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
index 85950e86006..172cc03d086 100644
--- a/src/nouveau/vulkan/nvk_physical_device.c
+++ b/src/nouveau/vulkan/nvk_physical_device.c
@@ -18,6 +18,7 @@
 
 #include "vulkan/runtime/vk_device.h"
 #include "vulkan/runtime/vk_drm_syncobj.h"
+#include "vulkan/runtime/vk_shader_module.h"
 #include "vulkan/wsi/wsi_common.h"
 
 #include <sys/stat.h>
@@ -175,6 +176,7 @@ nvk_get_device_extensions(const struct nv_device_info *info,
       .EXT_shader_image_atomic_int64 = info->cls_eng3d >= MAXWELL_A &&
                                        nvk_use_nak(info),
       .EXT_shader_demote_to_helper_invocation = true,
+      .EXT_shader_module_identifier = true,
       .EXT_shader_subgroup_ballot = true,
       .EXT_shader_subgroup_vote = true,
       .EXT_shader_viewport_index_layer = info->cls_eng3d >= MAXWELL_B,
@@ -462,6 +464,9 @@ nvk_get_device_features(const struct nv_device_info *info,
       .sparseImageInt64Atomics = info->cls_eng3d >= MAXWELL_A &&
                                  nvk_use_nak(info),
 
+      /* VK_EXT_shader_module_identifier */
+      .shaderModuleIdentifier = true,
+
       /* VK_EXT_texel_buffer_alignment */
       .texelBufferAlignment = true,
 
@@ -764,6 +769,13 @@ nvk_get_device_properties(const struct nvk_instance *instance,
    snprintf(properties->deviceName, sizeof(properties->deviceName),
             "%s", info->device_name);
 
+   /* VK_EXT_shader_module_identifier */
+   STATIC_ASSERT(sizeof(vk_shaderModuleIdentifierAlgorithmUUID) ==
+      sizeof(properties->shaderModuleIdentifierAlgorithmUUID));
+   memcpy(properties->shaderModuleIdentifierAlgorithmUUID,
+            vk_shaderModuleIdentifierAlgorithmUUID,
+            sizeof(properties->shaderModuleIdentifierAlgorithmUUID));
+
    const struct {
       uint16_t vendor_id;
       uint16_t device_id;
-- 
2.43.0


From 04db83b4bb26e769693c1435dee89d0bec92b32c Mon Sep 17 00:00:00 2001
From: "Echo J." <aidas957@gmail.com>
Date: Wed, 15 Nov 2023 10:33:08 +0200
Subject: [PATCH 8/8] nvk: Various pipeline caching patch hotfixes

---
 src/nouveau/vulkan/nvk_cmd_buffer.c        |  4 +-
 src/nouveau/vulkan/nvk_graphics_pipeline.c |  2 +-
 src/nouveau/vulkan/nvk_pipeline.c          |  6 +-
 src/nouveau/vulkan/nvk_shader.c            | 86 +++++++---------------
 src/nouveau/vulkan/nvk_shader.h            | 22 +++++-
 5 files changed, 53 insertions(+), 67 deletions(-)

diff --git a/src/nouveau/vulkan/nvk_cmd_buffer.c b/src/nouveau/vulkan/nvk_cmd_buffer.c
index 76a35bd52f1..4fb19e72115 100644
--- a/src/nouveau/vulkan/nvk_cmd_buffer.c
+++ b/src/nouveau/vulkan/nvk_cmd_buffer.c
@@ -542,8 +542,8 @@ nvk_CmdBindPipeline(VkCommandBuffer commandBuffer,
    for (unsigned s = 0; s < ARRAY_SIZE(pipeline->shaders); s++) {
       if (!pipeline->shaders[s])
          continue;
-      if (pipeline->shaders[s].info.slm_size)
-         nvk_device_ensure_slm(dev, pipeline->shaders[s].info.slm_size);
+      if (pipeline->shaders[s]->info.slm_size)
+         nvk_device_ensure_slm(dev, pipeline->shaders[s]->info.slm_size);
    }
 
    switch (pipelineBindPoint) {
diff --git a/src/nouveau/vulkan/nvk_graphics_pipeline.c b/src/nouveau/vulkan/nvk_graphics_pipeline.c
index 83b0957d7d4..81200b28076 100644
--- a/src/nouveau/vulkan/nvk_graphics_pipeline.c
+++ b/src/nouveau/vulkan/nvk_graphics_pipeline.c
@@ -339,7 +339,7 @@ nvk_graphics_pipeline_create(struct nvk_device *dev,
 
    struct vk_pipeline_cache_object *objects[MESA_SHADER_STAGES] = {};
 
-   struct nvk_fs_key fs_key_tmp, *fs_key = NULL;
+   struct nak_fs_key fs_key_tmp, *fs_key = NULL;
    nvk_populate_fs_key(&fs_key_tmp, state.ms, &state);
    fs_key = &fs_key_tmp;
 
diff --git a/src/nouveau/vulkan/nvk_pipeline.c b/src/nouveau/vulkan/nvk_pipeline.c
index 7c9d109e965..8a4f68574a7 100644
--- a/src/nouveau/vulkan/nvk_pipeline.c
+++ b/src/nouveau/vulkan/nvk_pipeline.c
@@ -128,7 +128,7 @@ nvk_GetPipelineExecutablePropertiesKHR(
                           pProperties, pExecutableCount);
 
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (pipeline->shaders[stage].code_size == 0)
+      if (pipeline->shaders[stage]->code_size == 0)
          continue;
 
       vk_outarray_append_typed(VkPipelineExecutablePropertiesKHR, &out, props) {
@@ -147,11 +147,11 @@ static struct nvk_shader *
 shader_for_exe_idx(struct nvk_pipeline *pipeline, uint32_t idx)
 {
    for (gl_shader_stage stage = 0; stage < MESA_SHADER_STAGES; stage++) {
-      if (pipeline->shaders[stage].code_size == 0)
+      if (pipeline->shaders[stage]->code_size == 0)
          continue;
 
       if (idx == 0)
-         return &pipeline->shaders[stage];
+         return pipeline->shaders[stage];
 
       idx--;
    }
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index 9de03b2bee5..5f343083711 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -459,34 +459,23 @@ VkResult
 nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rs,
-                const struct nvk_fs_key *fs_key,
+                const struct nak_fs_key *fs_key,
                 struct vk_pipeline_cache *cache,
                 unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out)
 {
    struct nvk_physical_device *pdev = nvk_device_physical(dev);
-
-<<<<<<< HEAD
-   struct nvk_shader *shader = nvk_shader_init(dev);
-   if (shader == NULL)
-=======
-   if (use_nak(pdev, nir->info.stage))
-      return nvk_compile_nir_with_nak(pdev, nir, fs_key, shader);
-
-   info = CALLOC_STRUCT(nv50_ir_prog_info);
-   if (!info)
-      return false;
+   VkResult result = VK_SUCCESS;
 
    struct nvk_shader *shader = nvk_shader_init(dev, hash, SHA1_DIGEST_LENGTH);
-   if(shader == NULL)
->>>>>>> cda60b14147 (nvk: pipeline shader cache)
+   if (shader == NULL)
       return vk_error(dev, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    if (use_nak(pdev, nir->info.stage))
-      VkResult result = nvk_compile_nir_with_nak(pdev, nir, pipeline_flags,
-                                                 rs, fs_key, shader);
+      result = nvk_compile_nir_with_nak(pdev, nir, pipeline_flags,
+                                        rs, fs_key, shader);
    else
-      VkResult result = nvk_cg_compile_nir(pdev, nir, fs_key, shader);
+      result = nvk_cg_compile_nir(pdev, nir, fs_key, shader);
 
    *shader_out = shader;
    return result;
@@ -564,7 +553,7 @@ nvk_hash_shader(unsigned char *hash,
                 const VkPipelineShaderStageCreateInfo *sinfo,
                 const struct vk_pipeline_robustness_state *rstate,
                 const struct vk_pipeline_layout *layout,
-                const struct nvk_fs_key *fs_key)
+                const struct nak_fs_key *fs_key)
 {
    struct mesa_sha1 ctx;
 
@@ -627,25 +616,17 @@ nvk_shader_serialize(struct vk_pipeline_cache_object *object,
    struct nvk_shader *shader =
       container_of(object, struct nvk_shader, base);
 
-   blob_write_bytes(blob, &shader->stage, sizeof(shader->stage));
+   blob_write_bytes(blob, &shader->info.stage, sizeof(shader->info.stage));
    blob_write_uint32(blob, shader->code_size);
-   blob_write_uint8(blob, shader->num_gprs);
-   blob_write_uint8(blob, shader->num_barriers);
-   blob_write_uint32(blob, shader->slm_size);
-   blob_write_bytes(blob, &shader->hdr, sizeof(shader->hdr));
-   blob_write_bytes(blob, &shader->flags, sizeof(shader->flags));
-
-   blob_write_bytes(blob, &shader->vs, sizeof(shader->vs));
-   blob_write_bytes(blob, &shader->fs, sizeof(shader->fs));
-   blob_write_bytes(blob, &shader->tp, sizeof(shader->tp));
-   blob_write_bytes(blob, &shader->cp, sizeof(shader->cp));
-
-   if (shader->xfb) {
-      blob_write_uint8(blob, 1);
-      blob_write_bytes(blob, shader->xfb, sizeof(*shader->xfb));
-   } else {
-      blob_write_uint8(blob, 0);
-   }
+   blob_write_uint8(blob, shader->info.num_gprs);
+   blob_write_uint8(blob, shader->info.num_barriers);
+   blob_write_uint32(blob, shader->info.slm_size);
+
+   blob_write_bytes(blob, &shader->info.hdr, sizeof(shader->info.hdr));
+   blob_write_bytes(blob, &shader->info.cs, sizeof(shader->info.cs));
+   blob_write_bytes(blob, &shader->info.fs, sizeof(shader->info.fs));
+   blob_write_bytes(blob, &shader->info.ts, sizeof(shader->info.ts));
+   blob_write_bytes(blob, &shader->info.vtg, sizeof(shader->info.vtg));
 
    blob_write_bytes(blob, shader->code_ptr, shader->code_size);
 
@@ -662,35 +643,22 @@ nvk_shader_deserialize(struct vk_pipeline_cache *cache,
       container_of(cache->base.device, struct nvk_device, vk);
    struct nvk_shader *shader =
       nvk_shader_init(dev, key_data, key_size);
-   struct nvk_transform_feedback_state *xfb = NULL;
    uint8_t *code_ptr = NULL;
 
    if (!shader)
       return NULL;
 
-   blob_copy_bytes(blob, &shader->stage, sizeof(shader->stage));
+   blob_copy_bytes(blob, &shader->info.stage, sizeof(shader->info.stage));
    shader->code_size = blob_read_uint32(blob);
-   shader->num_gprs = blob_read_uint8(blob);
-   shader->num_barriers = blob_read_uint8(blob);
-   shader->slm_size = blob_read_uint32(blob);
-
-   blob_copy_bytes(blob, &shader->hdr, sizeof(shader->hdr));
-   blob_copy_bytes(blob, &shader->flags, sizeof(shader->flags));
-
-   blob_copy_bytes(blob, &shader->vs, sizeof(shader->vs));
-   blob_copy_bytes(blob, &shader->fs, sizeof(shader->fs));
-   blob_copy_bytes(blob, &shader->tp, sizeof(shader->tp));
-   blob_copy_bytes(blob, &shader->cp, sizeof(shader->cp));
-
-   bool has_xfb = blob_read_uint8(blob);
-   if (has_xfb) {
-      xfb = malloc(sizeof(struct nvk_transform_feedback_state));
-      if(!xfb)
-         goto fail;
-
-      shader->xfb = xfb;
-      blob_copy_bytes(blob, shader->xfb, sizeof(*shader->xfb));
-   }
+   shader->info.num_gprs = blob_read_uint8(blob);
+   shader->info.num_barriers = blob_read_uint8(blob);
+   shader->info.slm_size = blob_read_uint32(blob);
+
+   blob_copy_bytes(blob, &shader->info.hdr, sizeof(shader->info.hdr));
+   blob_copy_bytes(blob, &shader->info.cs, sizeof(shader->info.cs));
+   blob_copy_bytes(blob, &shader->info.fs, sizeof(shader->info.fs));
+   blob_copy_bytes(blob, &shader->info.ts, sizeof(shader->info.ts));
+   blob_copy_bytes(blob, &shader->info.vtg, sizeof(shader->info.vtg));
 
    code_ptr = malloc(shader->code_size);
    if (!code_ptr)
diff --git a/src/nouveau/vulkan/nvk_shader.h b/src/nouveau/vulkan/nvk_shader.h
index fd57db2eb54..d9704142696 100644
--- a/src/nouveau/vulkan/nvk_shader.h
+++ b/src/nouveau/vulkan/nvk_shader.h
@@ -95,7 +95,7 @@ VkResult
 nvk_compile_nir(struct nvk_device *dev, nir_shader *nir,
                 VkPipelineCreateFlagBits2KHR pipeline_flags,
                 const struct vk_pipeline_robustness_state *rstate,
-                const struct nvk_fs_key *fs_key,
+                const struct nak_fs_key *fs_key,
                 struct vk_pipeline_cache *cache,
                 unsigned char hash[SHA1_DIGEST_LENGTH],
                 struct nvk_shader **shader_out);
@@ -113,10 +113,28 @@ nvk_hash_shader(unsigned char *hash,
                  const VkPipelineShaderStageCreateInfo *sinfo,
                  const struct vk_pipeline_robustness_state *rstate,
                  const struct vk_pipeline_layout *layout,
-                 const struct nvk_fs_key *fs_key);
+                 const struct nak_fs_key *fs_key);
 
 void
 nvk_shader_destroy(struct vk_device *dev,
                    struct vk_pipeline_cache_object *object);
 
+/* Codegen wrappers.
+ *
+ * TODO: Delete these once NAK supports everything.
+ */
+uint64_t nvk_cg_get_prog_debug(void);
+uint64_t nvk_cg_get_prog_optimize(void);
+
+const nir_shader_compiler_options *
+nvk_cg_nir_options(const struct nvk_physical_device *pdev,
+                   gl_shader_stage stage);
+
+void nvk_cg_preprocess_nir(nir_shader *nir);
+void nvk_cg_optimize_nir(nir_shader *nir);
+
+VkResult nvk_cg_compile_nir(struct nvk_physical_device *pdev, nir_shader *nir,
+                            const struct nak_fs_key *fs_key,
+                            struct nvk_shader *shader);
+
 #endif
-- 
2.43.0

